package lattice.lattice;

/*
 * Context.java
 *
 * last update on March 2010
 *
 */
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.*;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Iterator;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.TreeSet;
import lattice.dgraph.Node;

/**
 * This class gives a standard representation for a context. <p>
 * A context is a binary table, with attributes in column, and observations
 * in row.
 * <p>
 * A context is composed of attributes, a treeset of comparable objects ;
 * observations, a treeset of comparable objects ; and a Galois connexion
 * (extent,intent) between objects and attributes where
 * <code>extent</code> is a TreeMap that associates to each attribute a TreeSet of observations and
 * <code>intent</code> is a TreeMap that associates  to each observation a TreeSet of attributes.
 * <p>
 * This class provides methods implementing classical operation on a context:
 * closure, reduction, reverse, ...
 * <p>
 * A context owns properties of a closure system, and thus extends the abstract class
 * <code>ClosureSystem</code> and implements methods <code>getS</code> and <code>closure</code>. 
 * Therefore, the closed set lattice of a context can be generated by invoking method <code>closedSetLattice</code> of a closure system.  
 * However, this class also provides a method generating the concept lattice of this component
 * by completing each closed set of the closed set lattice.
 * <p>
 * A context can be instancied from and save to a text file in the following format:
 * The list of observations separated by a space on the first line ;
 * the list of attrbutes separated by a space on the second line ;
 * then, for each observations o, the list of its intent on a line, written like o a1 a2 ...
 * <pre>
 * Observations: 1 2 3
 * Attributes: a b c d e
 * 1 a c
 * 2 a b
 * 3 b d e
 * 4 c e
 * </pre>
 * <p>
 * Copyright: 2013 University of La Rochelle, France
 * @license: http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html CeCILL-B license
 * This file is part of lattice, free package. You can redistribute it and/or modify
 * it under the terms of CeCILL-B license.
 * @author Karell Bertet
 * @version 2013
 */
public class Context extends ClosureSystem {

	/* ------------- FIELD ------------------ */	
	
	/** A set of observations **/
	protected TreeSet<Comparable> observations;
	/** A set of attributes **/
	protected TreeSet<Comparable> attributes;
	/** A map to associate a set of attributes to each observation */
	protected TreeMap<Comparable,TreeSet<Comparable>> intent;
	/** A map to associate a set of observations to each attribute */
	protected TreeMap<Comparable,TreeSet<Comparable>> extent;

//cguerin 2013-06-26 - Optimisation des calculs par BitSets
    /* ------------- BITSET ADDON ------------------ */
    
    private BitSet b_attributes;
    private BitSet b_obersavtions;
    private TreeMap<Comparable,BitSet> b_intent;
    private TreeMap<Comparable,BitSet> b_extent;
    ArrayList<Comparable> array_observations;
    ArrayList<Comparable> array_attributes;
    public int vari;
    //fin cguerin
	/* ------------- CONSTRUCTORS ------------------ */	
	
  	/** Constructs a new empty context */
	public Context () {
		this.observations = new TreeSet<Comparable>();
		this.attributes = new TreeSet<Comparable>();
		this.intent = new TreeMap<Comparable,TreeSet<Comparable>>();
		this.extent = new TreeMap<Comparable,TreeSet<Comparable>>();
        this.b_attributes = new BitSet();
        this.b_obersavtions = new BitSet();
        this.b_intent = new TreeMap();
        this.b_extent = new TreeMap();
        this.array_observations = new ArrayList();
        this.array_attributes = new ArrayList();
		}		
  	/** Constructs a new context as a copy of the specified context */
    public Context (Context C) {
        this.observations = new TreeSet();
        this.attributes = new TreeSet();
        this.intent = new TreeMap();
        this.extent = new TreeMap();



        this.b_attributes = new BitSet();
        this.b_obersavtions = new BitSet();
        this.b_intent = new TreeMap();
        this.b_extent = new TreeMap();
        this.array_observations = new ArrayList();
        this.array_attributes = new ArrayList();
        
        //cguerin - 2013-04-20 - add attributes and observation copy
        this.attributes.addAll(C.getAttributes());
        this.observations.addAll(C.getObservations());
        //fin cguerin

        //cguerin - 2013-04-20 - fix intent/extent inversion
        for (Comparable o : C.getObservations()){
            this.intent.put(o, new TreeSet(C.getIntent(o)));
        }

        for (Comparable a : C.getAttributes()){                
            this.extent.put(a, new TreeSet(C.getExtent(a)));
        }
        //fin cguerin
    }
	
	/** Constructs this component from the specified file. <p>
	* The file have to respect a certain format : <p>
     * The list of observations separated by a space on the first line ;
     * the list of attrbutes separated by a space on the second line ;
     * then, for each observations o, the list of its intent on a line, written like o a1 a2 ...
     * <pre>
     * Observations: 1 2 3
     * Attributes: a b c d e
     * 1 a c
     * 2 a b
     * 3 b d e
     * 4 c e
     * </pre>
     * <p>
     * Each observation must be declared on the first line, otherwise, it is not added
	* Each attribute must be declared on the second line, otherwise, it is not added
	* @param filename the name of the file
	*/
	public Context (String filename) {
		this();	
		try {
			BufferedReader fichier = new BufferedReader(new FileReader(filename));						
			// first line : All observations separated by a space
			// a StringTokenizer is used to divide the line into different observations
            // considering spaces as separator.
			StringTokenizer st =  new StringTokenizer(fichier.readLine());	
			st.nextToken(); // first token corresponds to the string "Observations:"
			while (st.hasMoreTokens()) {
				String n = new String (st.nextToken());
				this.addToObservations(n);
				}  
			// second line : All attributes separated by a space
			// a StringTokenizer is used to divide the line into different token,
            // considering spaces as separator.
			st =  new StringTokenizer(fichier.readLine());	
			st.nextToken(); // first token corresponds to the string "Attributes:"
			while (st.hasMoreTokens()) {
				String n = new String (st.nextToken());
				this.addToAttributes(n);
				}  
			// next lines : All intents of observations, one on each line: 
			// observation : list of attributes
			// a StringTokenizer is used to divide each intent.
			String line;
			while ((line = fichier.readLine())!=null && !line.isEmpty()) {                
				st = new StringTokenizer(line);
				String word = st.nextToken();
				Comparable o = null;
				// search of o in observations
				for (Comparable e : this.getObservations())
						if (e.equals(word)) o=e;						
				if (o!=null) {
					word = st.nextToken(); // this token corresponds to the sting ":"
					while (st.hasMoreTokens()) {
						word = st.nextToken();
						Comparable a = null;
						// search of a in attributes 
						for (Comparable e : this.getAttributes())
							if (e.equals(word)) a=e;																				
						if (a!=null) 
							this.addExtentIntent(o,a);
					}
				}	
			}				
		fichier.close(); }
		catch (Exception e) { e.printStackTrace(); }
	}

	/** This fonction just for read file of Dounia	  
     * The following format is respected: 
		 *<p>
		 * For each observations o
		 * The name of observations separated on a line ;
		 * then, the list of frequence of each attrbutes intent on a line, written like a1 a2 ...
		 * <pre>
		 * 0002.png
		 * 0 0 0 3 0 0 3 0 0 0 0 0 6 0 5 3 11
		 * 0004.png
		 * 0 0 0 8 0 0 5 0 0 0 0 0 4 0 9 1 8
		 * 0007.png
		 * 0 0 0 3 0 0 4 0 0 0 0 0 27 0 3 4 9
		 * </pre>
		 * <p>
		 * @param numberTotalAtts : number total of the attributes in the orginal file
		 * @param deleteAtts : list of attributes deleted (attributes redundants)
     */
	public Context (String filename, int ThresholdBinary) {
		this();	
		try {
			BufferedReader fichier = new BufferedReader(new FileReader(filename));						
			String line;
			while ((line = fichier.readLine()) != null && !line.isEmpty()) { 				 
				// first line : an observation             
				StringTokenizer st = new StringTokenizer(line); 
				String o = new String (st.nextToken());
				this.addToObservations(o);
				
				// second line : All attributes separated by a space
				// a StringTokenizer is used to divide the line into different token,
            // considering spaces as separator.
				line = fichier.readLine();
				st = new StringTokenizer(line);
				int IdAtt = 0;
				while (st.hasMoreTokens()) {
					IdAtt += 1;
					int a = Integer.parseInt(st.nextToken());
					if (a > ThresholdBinary) {
						this.addToAttributes(Integer.toString(IdAtt));
						this.addExtentIntent(o,Integer.toString(IdAtt));
					}
				}			
			}				
			fichier.close(); 
		}
		catch (Exception e) { e.printStackTrace(); }
	}
	
	// function for read all file in a folder in a context C (files Dounia)
	public Context(String link, TreeSet<String> filesname, int ThresholdBinary) {
		this();	
		try {
			for (String fileName : filesname){
				BufferedReader fichier = new BufferedReader(new FileReader(link+fileName));						
				String line;
				while ((line = fichier.readLine()) != null && !line.isEmpty()) { 				 
					// first line : an observation             
					StringTokenizer st = new StringTokenizer(line); 
					String o = new String (st.nextToken());
					this.addToObservations(o);
					
					// second line : All attributes separated by a space
					// a StringTokenizer is used to divide the line into different token,
	            // considering spaces as separator.
					line = fichier.readLine();
					st = new StringTokenizer(line);
					int IdAtt = 0;
					while (st.hasMoreTokens()) {
						IdAtt += 1;
						int a = Integer.parseInt(st.nextToken());
						if (a > ThresholdBinary) {
							this.addToAttributes(Integer.toString(IdAtt));
							this.addExtentIntent(o,Integer.toString(IdAtt));
						}
					}			
				}				
				fichier.close();
			}
		}
		catch (Exception e) { e.printStackTrace(); }
	}
	/** This fonction just for read files of Van.
     * The following format is respected: 
		 *<p>
		 * The name of observations is the name of files
		 * For each file (observations o)
		 * Each line present an attrbute: id with the frequence of him.
		 * <pre>
		 * 1000.png
		 * 0 0
		 * 1 0
		 * 2 1
		 * ...
		 * 500 0
		 * </pre>
		 * <p>
		 * @param numberTotalAtts : number total of the attributes in the orginal file
		 * @param deleteAtts : list of attributes deleted (attributes redundants)
     */
	public Context ( TreeSet<String> linkFilesName, int ThresholdBinary) {
		this();	
		try {
			// Read each file
			for (String linkFileName : linkFilesName){
				// add an observation => file name
				StringTokenizer st = new StringTokenizer(linkFileName,"\\");
				String fileName = "";
				while (st.hasMoreTokens())
					fileName = st.nextToken();
				// remove .bow
				st = new StringTokenizer(fileName,".");
				String o = st.nextToken() + "." + st.nextToken();
				this.addToObservations(o);
				
				// add attributes
				// each line is an attribute
				// space is the sepaarator between id and value of attribute
				BufferedReader fichier = new BufferedReader(new FileReader(linkFileName));						
				String line;
				while ((line = fichier.readLine()) != null && !line.isEmpty()) {				             
					st = new StringTokenizer(line); 
					String id = st.nextToken();
					if(st.hasMoreTokens()) {
						int value = Integer.parseInt(st.nextToken());
						if (value > ThresholdBinary) {
							this.addToAttributes(id);
							this.addExtentIntent(o,id);
						}
					}			
				}				
				fichier.close(); 
			}
		}
		catch (Exception e) { e.printStackTrace(); }
	}

        
	/* --------------- HANDLING METHODS FOR ATTRIBUTES AND OBSERVATIONS ------------ */	
				
   /** Returns the set of attributes of this component */
   public TreeSet<Comparable> getAttributes () {
		return this.attributes; }		
	/** Checks if the specified attribute belong to this component */
	public boolean containsAttribute (Comparable att) {
		return this.attributes.contains(att); }
	/** Checks if the specified set of attributes belong to this component */
	public boolean containsAllAttributes (TreeSet<Comparable> X) {
		return this.attributes.containsAll(X); }
	/** Adds the specified element to the set of attributes of this component */	
	public boolean addToAttributes (Comparable att) {
		if (!this.containsAttribute(att)) 
			this.extent.put(att, new TreeSet<Comparable>());
		return this.attributes.add(att); }
	/** Adds the set of specified element to the set of attributes of this component */	
	public boolean addAllToAttributes (TreeSet<Comparable> X) {
		boolean all = true;
		for (Comparable att : X)
			if (!this.addToAttributes(att) )
				all = false;
		return all;	 }
	/** Removes the specified element from the set of attributes of this component 
	* and from all the intents it belongs to */	
	public boolean removeFromAttributes (Comparable att) {
		this.extent.remove(att);
		for (Comparable o : this.getObservations())
			this.intent.get(o).remove(att);
		return this.attributes.remove(att); }
		
   /** Returns the set of observations of this component */
   public TreeSet<Comparable> getObservations () {
		return this.observations; }
	/** Checks if the specified observation belong to this component */
	public boolean containsObservation (Comparable obs) {
		return this.observations.contains(obs); }
	/** Checks if the specified set of observations belong to this component */
	public boolean containsAllObservations (TreeSet<Comparable> X) {
		return this.observations.containsAll(X); }
	/** Adds the specified element to the set of observations of this component */	
	public boolean addToObservations (Comparable obs) {
		if (!this.containsObservation(obs)) 
			this.intent.put(obs, new TreeSet<Comparable>());
		return this.observations.add(obs); }
	/** Adds the set of specified element to the set of observations of this component */	
	public boolean addAllToObservations (TreeSet<Comparable> X) {
		boolean all = true;
		for (Comparable obs : X)
			if (!this.addToObservations(obs)) 
				all = false;
		return all;	 }
		
	/** Removes the specified element from the set of observations of this component 
	* and from all the extents it belongs to */		
	public boolean removeFromObservations (Comparable obs) {
		this.intent.remove(obs);
		for (Comparable att : this.getAttributes())
			this.extent.get(att).remove(obs);
		return this.observations.remove(obs); }
		
        //cguerin - 2013-06-28 - Setting of necessary variables for bitsets
        
        /*
         * Set the needed structures for the bitset optimization.
         * WARNING: this must be called each time your dataset change
         */
        public void setBitSets(){
            this.setMaps();
            this.setBitSetsIntentExtent();
        }
        
        /*
         * Set the mapping structure for the bitset optimization
         */
        private void setMaps(){
            Iterator<Comparable> i = attributes.iterator();
            int cpt = 0;
            while(i.hasNext()){
                Comparable c = i.next();
                array_attributes.add(c);
                ++cpt;
            }
            
            i = observations.iterator();
            cpt=0;
            while(i.hasNext()){
                Comparable c = i.next();
                array_observations.add(c);
                ++cpt;
            }
        }
        
        /*
         * Set the extent and intent structures for the bitset optimization
         */
        private void setBitSetsIntentExtent(){
            Iterator<Comparable> i = attributes.iterator();
            BitSet b = new BitSet(this.observations.size());
            while(i.hasNext()){
                Comparable att = i.next();
                for(Comparable c : this.extent.get(att)){
                    b.set(array_observations.indexOf(c));
                }
                b_extent.put(att, (BitSet)b.clone());
                b.clear();
            }
            i = observations.iterator();
            b = new BitSet(this.attributes.size());
            while(i.hasNext()){
                Comparable obs = i.next();
                for(Comparable c : this.intent.get(obs)){
                    b.set(array_attributes.indexOf(c));
                }
                b_intent.put(obs, (BitSet)b.clone());
                b.clear();
            }
        }
        
        //fin cguerin
	/* --------------- HANDLING METHODS FOR INTENT AND EXTENT ------------ */	
			
  	/** Returns the set of observations that are intent of the specified observation  */
  	public TreeSet<Comparable> getIntent (Comparable obs) {            
            if (this.containsObservation(obs)){
                return this.intent.get(obs);
            }
            else {
                return new TreeSet<>();

            } 
        }
  	/** Returns the set of observations that are all intent of attributes of the specified set */
        public TreeSet<Comparable> getIntent (TreeSet<Comparable> X) {                    
            TreeSet<Comparable> resIntent = new TreeSet<Comparable>(this.getAttributes());            
            for (Comparable obs : X){
                resIntent.retainAll(this.getIntent(obs));
            }
            return resIntent;            
        }
	/** Checks if the second specified element is an intent of the first specified element */
	public boolean containAsIntent (Comparable obs, Comparable att ) {
		if (this.containsObservation(obs) && this.containsAttribute(att))
			return this.intent.get(obs).contains(att);		
		else return false; }		

  	/** Returns the set of attributes that are intent of the specified observation  */
  	public TreeSet<Comparable> getExtent (Comparable att) {
            if (this.containsAttribute(att)){
                return this.extent.get(att);
            }
            else {
                return new TreeSet<>();

            } 
        }
  	/** Returns the set of attributes that are all intent of observations of the specified set */
  	public TreeSet<Comparable> getExtent (TreeSet<Comparable> X) {
            TreeSet<Comparable> ext = new TreeSet<Comparable>(this.getObservations());
            for (Comparable att : X){
                ext.retainAll(this.getExtent(att));
            }
            return ext;
        }		
	public int getExtentNb (TreeSet<Comparable> X) {
            int size = this.getObservations().size();
            BitSet b_resExtent = new BitSet(size);
            b_resExtent.set(0, size);
            for (Comparable att : X){
                try{
                    b_resExtent.and(this.b_extent.get(att));
                }
                catch(NullPointerException e){
                    return 0;
                }
            }
            return b_resExtent.cardinality();
        }
	/** Checks if the second specified element is an intent of the first specified element */
	public boolean containAsExtent (Comparable att, Comparable obs ) {
            if (this.containsObservation(obs) && this.containsAttribute(att)){
                return this.extent.get(att).contains(obs);		

            }
            else {
                return false;
            } 
        }	


	/** Adds the second specified element as intent of the first one, 
	* and the first one as extent of the second one.
	* The first one has to belong to the observations set 
	* and the second one to the attribute set.
	*/
	public boolean addExtentIntent (Comparable obs, Comparable att ) {
		if (this.containsObservation(obs) && this.containsAttribute(att))
			return this.intent.get(obs).add(att) && this.extent.get(att).add(obs);
		else return false; }		
	/** Removes the second specified element from the intent of the first one, 
	* and the first one from the extent of the second one.
	* The first one has to belong to the observations set 
	* and the second one to the attribute set.
	*/
	public boolean removeExtentIntent (Comparable obs, Comparable att ) {
		if (this.containsObservation(obs) && this.containsAttribute(att))
			return this.intent.get(obs).remove(att) && this.extent.get(att).remove(obs);
		else return false; }		

				
	/* --------------- CONTEXT HANDLING METHODS ------------ */		

	/** Returns a String representation of this component.
     * The following format is respected: <p>
	* The list of observations separated by a space on the first line ;
     * the list of attrbutes separated by a space on the second line ;
     * then, for each observations o, the list of its intent on a line, written like o a1 a2 ...
     * <pre>
     * Observations: 1 2 3
     * Attributes: a b c d e
     * 1 a c
     * 2 a b
     * 3 b d e
     * 4 c e
     * </pre>
     */
	public String toString() {
            StringBuffer string = new StringBuffer ();
            string.append ("Observations: ");
            for (Comparable o : this.observations) {
            // first line : All observations separated by a space
            // a StringTokenizer is used to delete spaces in the
            // string description of each observation
            StringTokenizer st = new StringTokenizer(o.toString());
            while (st.hasMoreTokens())
                string.append(st.nextToken());
		string.append(" ");
		}
            string.append("\nAttributes: ");
            for (Comparable a : this.attributes) {
            // second line : All attributes separated by a space
            // a StringTokenizer is used to delete spaces in the
            // string description of each observation
                StringTokenizer st = new StringTokenizer(a.toString());
                while (st.hasMoreTokens())
                    string.append(st.nextToken());
                    string.append(" ");
		}
		// next lines : All intents of observations, one on each line:
		// observation : list of attributes
		// a StringTokenizer is used to delete spaces in the
        // string description of each observation and attributes
		string.append("\n");
		for (Comparable o : this.observations) {
            StringTokenizer st = new StringTokenizer(o.toString());
            while (st.hasMoreTokens())
                string.append(st.nextToken());
		string.append(" : ");
		for (Comparable a : this.getIntent(o)) {
                    st = new StringTokenizer(a.toString());
                while (st.hasMoreTokens())
                    string.append(st.nextToken());		
                string.append(" ");
                }
		string.append("\n");	
		}
		return string.toString();
	}
	/** Saves this component in a text file which name is specified. <p>
     * The following format is respected: <p>
	* The list of observations separated by a space on the first line ;
     * the list of attrbutes separated by a space on the second line ;
     * then, for each observations o, the list of its intent on a line, written like o a1 a2 ...
     * <pre>
     * Observations: 1 2 3
     * Attributes: a b c d e
     * 1 a c
     * 2 a b
     * 3 b d e
     * 4 c e
     * </pre>
	* @param filename the name of the file 
	*/
	public void toFile(String filename)	{
		try 	{
			BufferedWriter fichier = new BufferedWriter(new FileWriter(filename));
			fichier.write(this.toString());				
            fichier.close();
    	}
    	catch (Exception e) { e.printStackTrace(); } 
	}
	
	/** Removes from this component reducible attributes. <p>
	* Reducible attributes are attributes equivalent by closure to others attributes.   
        * They are computed by <code>getReducibleElements</code> od <code>ClosureSystem</code> in O(|A|^3|O|)
	* @return the set of reducibles removed attributes, with their equivalent attributes
	*/
	public TreeMap <Comparable, TreeSet<Comparable>> attributesReduction () {
            // compute the reducible elements            
            TreeMap Red = this.getReducibleElements();            
            // remove the reducible elements from the attributes set
            for (Object att : Red.keySet()) 
                this.removeFromAttributes((Comparable)att);            
            return Red;
        }
         
        /** Removes from this component reducible observations. <p>
	* Reducible observations are attributes equivalent by closure to others observations.         
        * They are computed by <code>getReducibleElements</code> od <code>ClosureSystem</code>
        * applied on the reverse context in O(|O|^3|A|)
	* @return the set of reducibles removed attributes, with their equivalent attributes
	*/
	public TreeMap <Comparable, TreeSet<Comparable>> observationsReduction () {
            // compute the reducible elements of the reverse context            
            this.reverse();
            TreeMap Red = this.getReducibleElements();            
            this.reverse();
            // remove the reducible elements from the observations set
            for (Object att : Red.keySet()) 
                this.removeFromObservations((Comparable)att);            
            return Red;
        }
	/** Removes from this component reducible attributes and observations. <p>
        * They are computed by <code>attributesReduction</code> then 
        * <code>observationsReduction</code> in O(|A|^3|O|+|O|^3|A|)
	* <p>
	* @return the set of reducibles removed attributes and observations with their equivalent elements
	*/	
	public TreeMap <Comparable, TreeSet<Comparable>> reduction () {
            TreeMap <Comparable, TreeSet<Comparable>> Red = this.attributesReduction();
            Red.putAll(this.observationsReduction());
            return Red;
	}	
	/** Reverses this component by replacing attributes by observations and observations by 
	* attributes. Intent and extent are exchanged in the same way.
	*/
	public void reverse () {
		TreeSet<Comparable> tmp = this.attributes;
		this.attributes = this.observations;
		this.observations = tmp;
		TreeMap<Comparable,TreeSet<Comparable>> sauv = this.intent;
		this.intent = this.extent;
		this.extent = sauv;			
	}

        //cguerin - 2013-04-20 - return a new reversed Context
        public Context getReverseContext(){
            Context context = new Context(this);
            TreeSet<Comparable> tmp = context.attributes;
            context.attributes = context.observations;
            context.observations = tmp;
            TreeMap<Comparable,TreeSet<Comparable>> sauv = context.intent;
            context.intent = context.extent;
            context.extent = sauv;
            return context;
        }
    /* --------------- IMPLEMENTATION OF CLOSURE SYSTEM ABSTRACT METHODS ------------ */
	/* --------------- AND CONCEPT LATTICE GENERATION------------ */



	/** Returns the set of attributes as elements set used by the lattice generator abstract class
	* to generate closed set lattice on attributes. The closed set lattice on abservations can
	* be otained using the reverse method of this class.
	*/
	public TreeSet<Comparable> getSet() {
		return this.attributes;
	}
	/**  Builds the closure of a set X of attributes. <p>
	* The closure corresponds to the maximal set of attributes having the
	* same intent as the specified one.
	* This treatment is performed in O(|A||O|)
	* @param X a TreeSet of indexed elements
	* @return  the closure of X for this component
	*/
	public TreeSet<Comparable> closure (TreeSet<Comparable> X) {
		return this.getIntent(this.getExtent(X));
	}        
	/** Returns the set of union of observations that are intent with one of attributes of the specified set */
  	public TreeSet<Comparable> getExtentUnion (TreeSet<Comparable> X) {
		TreeSet<Comparable> ext = new TreeSet<Comparable>();
		for (Comparable att : X)
			for (Comparable obs : this.getExtent(att))
				if (this.containAsExtent(att,obs) && !ext.contains(obs))
					ext.add(obs);
		return ext; }

	/**  Builds the inverse of the closure operator of a set X of observations. <p>
	* The inverse closure corresponds to the maximal set of observations having the
	* same intent as the specified one.
	* This treatment is performed in O(|A||O|)
	* @param X a TreeSet of indexed elements
	* @return  the closure of X for this component
	*/
	public ComparableSet inverseClosure (ComparableSet X) {
		return new ComparableSet (this.getExtent(this.getIntent((TreeSet)X)));
	}

    /** Returns the concept lattice of this component. <p>
    * A true value of the boolean <code>diagram</code> indicates that the
     * Hasse diagramm of the lattice is computed (i.e. it is transitively reduced),
     * whereas a false value indicates that the lattice is transitively closed
     * <p>
     * The closed set lattice is first generated using
     * <code>ConceptLattice closedSetLattice (boolean  diagram)</code>
     * Then, nodes of the lattice are completed as concepts.
     *
     * @param diagram a boolean indicating if the Hasse diagramm of the lattice is computed or not.
	 **/
	public ConceptLattice conceptLattice (boolean  diagram) {
		ConceptLattice CSL = this.closedSetLattice(diagram);        
		TreeMap<Concept,Concept> Nodes = new TreeMap<Concept,Concept>();
		for (Node n : CSL.getNodes()) {
			 Concept cl = (Concept)n;
             cl.putSetB(new ComparableSet(this.getExtent(cl.getSetA())));
        }
		return CSL;
	}

}// end of Context		