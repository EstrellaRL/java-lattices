<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>LatticeFactory.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Java Lattices</a> &gt; <a href="index.source.html" class="el_package">lattice</a> &gt; <span class="el_source">LatticeFactory.java</span></div><h1>LatticeFactory.java</h1><pre class="source lang-java linenums">package lattice;
/*
 * LatticeFactory.java
 *
 * Copyright: 2013 University of La Rochelle, France
 *
 * License: http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html CeCILL-B license
 *
 * This file is part of lattice, free package. You can redistribute it and/or modify
 * it under the terms of CeCILL-B license.
 *
 * @version 2014
 */

import dgraph.DAGraph;
import dgraph.Node;
import java.util.BitSet;
import java.util.Iterator;

/**
 * This class provides a few methods to constructs lattice examples.
 *
 * ![LatticeFactory](LatticeFactory.png)
 *
 * @uml LatticeFactory.png
 * !include src/lattice/LatticeFactory.iuml
 *
 * class LatticeFactory #LightCyan
 * title LatticeFactory UML graph
 * @author jeff
 */
public class LatticeFactory {
    /**
     * Empty constructor.
     */
    protected LatticeFactory() {
<span class="fc" id="L37">        super();</span>
<span class="fc" id="L38">    }</span>
    /**
     * Returns a randomly generated lattice with nb nodes.
     *
     * @param nb Number of nodes in the randomly generated lattice
     * @return a randomly generated lattice with nb nodes
     */
    public static Lattice random(int nb) {
<span class="fc" id="L46">        boolean done = false;</span>
<span class="fc" id="L47">        Lattice l = new Lattice();</span>
<span class="fc bfc" id="L48" title="All 2 branches covered.">        while (!done) {</span>
<span class="fc" id="L49">            DAGraph dag = DAGraph.random(nb - 2); // what an ugly strategy :-(</span>
<span class="fc" id="L50">            Lattice tmp = new Lattice(dag);</span>
<span class="fc" id="L51">            Node top = new Node(new Integer(nb - 1));</span>
<span class="fc" id="L52">            tmp.addNode(top);</span>
<span class="fc bfc" id="L53" title="All 2 branches covered.">            for (Node n : tmp.max()) {</span>
<span class="fc bfc" id="L54" title="All 2 branches covered.">                if (!n.equals(top)) {</span>
<span class="fc" id="L55">                    tmp.addEdge(n, top);</span>
                }
<span class="fc" id="L57">            }</span>
<span class="fc" id="L58">            Node bot = new Node(new Integer(nb));</span>
<span class="fc" id="L59">            tmp.addNode(bot);</span>
<span class="fc bfc" id="L60" title="All 2 branches covered.">            for (Node n : tmp.min()) {</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">                if (!n.equals(bot)) {</span>
<span class="fc" id="L62">                    tmp.addEdge(bot, n);</span>
                }
<span class="fc" id="L64">            }</span>
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">            if (tmp.isLattice()) {</span>
<span class="fc" id="L66">                done = true;</span>
<span class="fc" id="L67">                l = tmp;</span>
            }
<span class="fc" id="L69">        }</span>
<span class="fc" id="L70">        return l;</span>
    }
    /**
     * Returns the boolean algebra of cardinal 2^n.
     *
     * @param n cardinal of the boolean algebra return by this method is 2^n
     * @return the boolean algebra of cardinal 2^n
     */
    public static Lattice booleanAlgebra(int n) {
<span class="fc" id="L79">        Lattice l = new Lattice();</span>
<span class="fc" id="L80">        BitSet b = new BitSet(n);</span>
<span class="fc" id="L81">        Node bot = new Node(b);</span>
<span class="fc" id="L82">        l.addNode(bot);</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L84">            BitSet bs = new BitSet(n);</span>
<span class="fc" id="L85">            bs.set(i, true);</span>
<span class="fc" id="L86">            Node next = new Node(bs);</span>
<span class="fc" id="L87">            l.addNode(next);</span>
<span class="fc" id="L88">            l.addEdge(bot, next);</span>
<span class="fc" id="L89">            recursiveBooleanAlgebra(next, l, n);</span>
        }
<span class="fc" id="L91">        return l;</span>
    }
    /**
     * Computes successors of node n in the boolean algebra currently generated.
     *
     * @param node this method compute successors of this node
     * @param l boolean algebra currently generated
     * @param n the number of node of l will be 2^n at the end of computation
     */
    private static void recursiveBooleanAlgebra(Node node, Lattice l, int n) {
<span class="fc bfc" id="L101" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L102">            BitSet b = (BitSet) node.getContent();</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">            if (!b.get(i)) {</span>
<span class="fc" id="L104">                BitSet bs = (BitSet) b.clone();</span>
<span class="fc" id="L105">                bs.set(i, true);</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">                if (l.getNodeByContent(bs) == null) {</span>
<span class="fc" id="L107">                    Node next = new Node(bs);</span>
<span class="fc" id="L108">                    l.addNode(next);</span>
<span class="fc" id="L109">                    l.addEdge(node, next);</span>
<span class="fc" id="L110">                    recursiveBooleanAlgebra(next, l, n);</span>
<span class="fc" id="L111">                } else {</span>
<span class="fc" id="L112">                    l.addEdge(node, l.getNodeByContent(bs));</span>
                }
            }
        }
<span class="fc" id="L116">    }</span>
    /**
     * Returns the lattice of permutations of 1..n.
     *
     * Permutation are ordered as follows :
     * A permutation s2 is a succesor of a permutation s1, if s2 is obtained from s1 by inverting two consecutive
     * elements i and j such that before inversion j &gt; i.
     *
     * Example : 124356 has following successors 214356, 142356, 124536 and 124365.
     *
     * The bottom of this lattice is identity (for exemple 123456) and the top is for instance 654321.
     *
     * @param n the lattice of permutations of the set 1..n
     * @return the lattice of permutations of 1..n.
     */
    public static Lattice permutationLattice(int n) {
<span class="fc" id="L132">        Lattice l = new Lattice();</span>
<span class="fc" id="L133">        int[] content = new int[n];</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L135">            content[i] = i;</span>
        }
<span class="fc" id="L137">        Permutation s = new Permutation(n);</span>
<span class="fc" id="L138">        s.setContent(content);</span>
<span class="fc" id="L139">        Node bot = new Node(s);</span>
<span class="fc" id="L140">        l.addNode(bot);</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">        for (int i = 0; i &lt; n - 1; i++) {</span>
<span class="fc" id="L142">            int[] newC = content.clone();</span>
<span class="fc" id="L143">            newC[i] = content[i + 1];</span>
<span class="fc" id="L144">            newC[i + 1] = content[i];</span>
<span class="fc" id="L145">            Permutation newS = new Permutation(n);</span>
<span class="fc" id="L146">            newS.setContent(newC);</span>
<span class="fc" id="L147">            Node succ = new Node(newS);</span>
<span class="fc" id="L148">            l.addNode(succ);</span>
<span class="fc" id="L149">            l.addEdge(bot, succ);</span>
<span class="fc" id="L150">            recursivePermutationLattice(succ, l, n);</span>
        }
<span class="fc" id="L152">        return l;</span>
    }
    /**
     * Computes successors of node n in the lattice l.
     *
     * @param node successors of this node are computed by this method
     * @param l lattice of permutations currently generated
     * @param n lattice of permutation of the set 1..n is currently generated
     */
    private static void recursivePermutationLattice(Node node, Lattice l, int n) {
<span class="fc" id="L162">        Permutation s = (Permutation) node.getContent();</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">        for (int i = 0; i &lt; s.getLength() - 1; i++) {</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">            if (s.getContent()[i] &lt; s.getContent()[i + 1]) {</span>
<span class="fc" id="L165">                int[] newC = s.getContent().clone();</span>
<span class="fc" id="L166">                Node currentNode = new Node();</span>
<span class="fc" id="L167">                newC[i] = s.getContent()[i + 1];</span>
<span class="fc" id="L168">                newC[i + 1] = s.getContent()[i];</span>
<span class="fc" id="L169">                Permutation newP = new Permutation(n);</span>
<span class="fc" id="L170">                newP.setContent(newC);</span>
<span class="fc" id="L171">                boolean newNode = true;</span>
<span class="fc" id="L172">                Iterator&lt;Node&gt; it = l.getNodes().iterator();</span>
<span class="fc bfc" id="L173" title="All 4 branches covered.">                while (it.hasNext() &amp;&amp; newNode) {</span>
<span class="fc" id="L174">                    currentNode = it.next();</span>
<span class="fc" id="L175">                    Permutation currentContent = (Permutation) currentNode.getContent();</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">                    newNode = !(currentContent.equals(newP));</span>
<span class="fc" id="L177">                }</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">                if (newNode) {</span>
<span class="fc" id="L179">                    Permutation newS = new Permutation(n);</span>
<span class="fc" id="L180">                    newS.setContent(newC);</span>
<span class="fc" id="L181">                    Node next = new Node(newS);</span>
<span class="fc" id="L182">                    l.addNode(next);</span>
<span class="fc" id="L183">                    l.addEdge(node, next);</span>
<span class="fc" id="L184">                    recursivePermutationLattice(next, l, n);</span>
<span class="fc" id="L185">                } else {</span>
<span class="fc" id="L186">                    l.addEdge(node, currentNode);</span>
                }
            }
        }
<span class="fc" id="L190">    }</span>
    /**
     * Returns the lattice cartesian product of l and r.
     *
     * A node in the product is a cartesian product of two nodes
     *
     * There is an edge (n1, m1) -&gt; (n2, m2) if and only if there are edges n1 -&gt; n2 and m1 -&gt; m2
     *
     * @param l Lattice of the left hand side of the product
     * @param r Lattice of the right hand side of the product
     * @return the lattice cartesian product of l and r
     */
    public static Lattice product(Lattice l, Lattice r) {
<span class="fc" id="L203">        Lattice prod = new Lattice();</span>
        // Create nodes
<span class="fc bfc" id="L205" title="All 2 branches covered.">        for (Node nL : l.getNodes()) {</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">            for (Node nR : r.getNodes()) {</span>
<span class="fc" id="L207">                prod.addNode(new Node(new Couple(nL.getContent(), nR.getContent())));</span>
<span class="fc" id="L208">            }</span>
<span class="fc" id="L209">        }</span>
        // Create edges
<span class="fc bfc" id="L211" title="All 2 branches covered.">        for (Node from : prod.getNodes()) {</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">            for (Node to : prod.getNodes()) {</span>
<span class="fc bfc" id="L213" title="All 4 branches covered.">                if (l.containsEdge(l.getNodeByContent(((Couple) from.getContent()).getLeft()),</span>
                        l.getNodeByContent(((Couple) to.getContent()).getLeft()))
                        &amp;&amp; r.containsEdge(r.getNodeByContent(((Couple) from.getContent()).getRight()),
                                r.getNodeByContent(((Couple) to.getContent()).getRight()))) {
<span class="fc" id="L217">                    prod.addEdge(from, to);</span>
                }
<span class="fc" id="L219">            }</span>
<span class="fc" id="L220">        }</span>
<span class="fc" id="L221">        return prod;</span>
    }
    /**
     * Returns lattice l in which convex c has been doubled.
     *
     * @param l a lattice
     * @param c a convex subset of l, to be doubled.
     * @return a lattice construct from l by doubling the convex subset c.
     */
    public static Lattice doublingConvex(Lattice l, DAGraph c) {
<span class="fc" id="L231">        Lattice doubled = new Lattice();</span>
        // Copy nodes by Content
<span class="fc bfc" id="L233" title="All 2 branches covered.">        for (Node n : l.getNodes()) {</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">            if (c.containsNode(n)) {</span>
                // These nodes are doubled
<span class="fc" id="L236">                Couple cpl0 = new Couple(n.getContent(), 0);</span>
<span class="fc" id="L237">                Node n0 = new Node(cpl0);</span>
<span class="fc" id="L238">                Couple cpl1 = new Couple(n.getContent(), 1);</span>
<span class="fc" id="L239">                Node n1 = new Node(cpl1);</span>
<span class="fc" id="L240">                doubled.addNode(n0);</span>
<span class="fc" id="L241">                doubled.addNode(n1);</span>
<span class="fc" id="L242">            } else {</span>
                // These nodes are just copied
<span class="fc" id="L244">                doubled.addNode(new Node(n.getContent()));</span>
            }
<span class="fc" id="L246">        }</span>
        // Construct edges of doubled
<span class="fc" id="L248">        Couple test = new Couple(0, 0); // used to test class of contents</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">        for (Node x : doubled.getNodes()) {</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">            for (Node y : doubled.getNodes()) {</span>
                // Add an edge if x &lt; y
<span class="fc bfc" id="L252" title="All 2 branches covered.">                if (x.getContent().getClass() == test.getClass()) { // x was in convex c</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">                    if (y.getContent().getClass() == test.getClass()) { // y was also in convex c</span>
                        // x &amp; y were in convex c
<span class="fc" id="L255">                        Couple cX = (Couple) x.getContent();</span>
<span class="fc" id="L256">                        Couple cY = (Couple) y.getContent();</span>
<span class="fc bfc" id="L257" title="All 6 branches covered.">                        if ((cX.getLeft() == cY.getLeft()) &amp;&amp; (((Integer) cX.getRight()).intValue() == 0)</span>
                                &amp;&amp; (((Integer) cY.getRight()).intValue() == 1)) {
                            // Same content means same node. x is of the form (cX, 0) and y is of the for (cX, 1) so x &lt; y in doubled.
<span class="fc" id="L260">                            doubled.addEdge(x, y);</span>
                        } else {
<span class="fc bfc" id="L262" title="All 4 branches covered.">                            if (l.majorants(l.getNodeByContent(cX.getLeft())).contains(l.getNodeByContent(cY.getLeft()))</span>
                                    &amp;&amp; (cX.getRight() == cY.getRight())) {
                                // x &lt; y in l and x &amp; y have the same second component si x &lt; y in doubled.
<span class="fc" id="L265">                                doubled.addEdge(x, y);</span>
                            }
                        }
<span class="fc" id="L268">                    } else { // y wasn't in convex c</span>
                        // x was in c &amp; y wasn't
<span class="fc" id="L270">                        Couple cX = (Couple) x.getContent();</span>
<span class="pc bpc" id="L271" title="1 of 4 branches missed.">                        if (l.majorants(l.getNodeByContent(cX.getLeft())).contains(l.getNodeByContent(y.getContent()))</span>
                                &amp;&amp; (((Integer) cX.getRight()).intValue() == 1)) {
                            // x &lt; y in l and second component of x is 1.
<span class="fc" id="L274">                            doubled.addEdge(x, y);</span>
                        }
<span class="fc" id="L276">                    }</span>
                } else { // x wasn't in convex c
<span class="fc bfc" id="L278" title="All 2 branches covered.">                    if (y.getContent().getClass() == test.getClass()) { // y was in convex c</span>
                        // x wasn't in c but y was
<span class="fc" id="L280">                        Couple cY = (Couple) y.getContent();</span>
<span class="pc bpc" id="L281" title="3 of 4 branches missed.">                        if (l.majorants(l.getNodeByContent(x.getContent())).contains(l.getNodeByContent(cY.getLeft()))</span>
                                &amp;&amp; (((Integer) cY.getRight()).intValue() == 0)) {
                                // x &lt; y in l and x &amp; second component of y is 0.
<span class="nc" id="L284">                                doubled.addEdge(x, y);</span>
                            }
<span class="fc" id="L286">                    } else { // y wasn't in convex c</span>
                        // x wasn't in c nor y
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">                        if (l.majorants(l.getNodeByContent(x.getContent())).contains(l.getNodeByContent(y.getContent()))) {</span>
                                // x &lt; y in l and x &amp; second component of y is 0.
<span class="nc" id="L290">                                doubled.addEdge(x, y);</span>
                            }
                    }
                }
<span class="fc" id="L294">            }</span>
<span class="fc" id="L295">        }</span>
<span class="fc" id="L296">        doubled.transitiveReduction();</span>
<span class="fc" id="L297">        return doubled;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.5.201403032054</span></div></body></html>