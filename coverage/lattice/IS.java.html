<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>IS.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Java Lattices</a> &gt; <a href="index.source.html" class="el_package">lattice</a> &gt; <span class="el_source">IS.java</span></div><h1>IS.java</h1><pre class="source lang-java linenums">package lattice;

/*
 * IS.java
 *
 * last update on May 2013
 *
 */

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.util.Collection;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.TreeSet;
import dgraph.DGraph;
import dgraph.Edge;
import dgraph.Node;
/**
* This class gives a representation for an implicational system (IS), i.e. a set of rules.
 *
 * An IS is composed of a treeset of comparable elements, and a treeset of rules
 * defined by class `Rule`.
 *
 * This class provides methods implementing classical transformation of an implicational system:
 * make proper, make minimum, make right maximal, make left minimal, make unary,
 * make canonical basis, make canonical direct basis and reduction.
 *
 * An implicational system owns properties of a closure system, and thus extends the abstract class
 * `ClosureSystem` and implements methods `getS` and `closure`.
 * Therefore, the closed set lattice of an IS can be generated by invoking method `closedSetLattice` of a closure system.
 *
 * An implicational system can be instancied from and save to a text file in the following format:
 * A list of elements separated by a space in the first line ;
 * then, each rule on a line, written like [premise] -&gt; [conclusion]
 * where elements are separated by a space.
 *
 *     a b c d e
 *     a b -&gt; c d
 *     c d -&gt; e
 *
 * Copyright: 2013 University of La Rochelle, France
 *
 * License: http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html CeCILL-B license
 *
 * This file is part of lattice, free package. You can redistribute it and/or modify
 * it under the terms of CeCILL-B license.
 *
 * @author Karell Bertet
 * @version 2013
 */
public class IS extends ClosureSystem
{
	/*--------------- FIELDS -----------------*/
	
	/** For the implicational rules of this component*/
	private TreeSet&lt;Rule&gt; sigma;
	/** For the elements space of this component */
	private TreeSet&lt;Comparable&gt; S;
	
	/* --------------- CONSTRUCTORS -----------*/
	
	/** Constructs a new empty component */
<span class="fc" id="L66">	public IS() { </span>
<span class="fc" id="L67">		this.sigma = new TreeSet&lt;Rule&gt;();</span>
<span class="fc" id="L68">		this.S = new TreeSet&lt;Comparable&gt;();</span>
<span class="fc" id="L69">	}	</span>
		
	/** Constructs this component from the specified set of rules `sigma`.
	* @param sigma the set of rules 
	*/
<span class="fc" id="L74">	public IS (Collection&lt;Rule&gt; sigma) {</span>
<span class="fc" id="L75">		this.sigma = new TreeSet&lt;Rule&gt;(sigma);</span>
<span class="fc" id="L76">		this.S = new TreeSet&lt;Comparable&gt;();</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">		for (Rule r: this.sigma) {</span>
<span class="fc" id="L78">			S.addAll(r.getPremise());</span>
<span class="fc" id="L79">			S.addAll(r.getConclusion());</span>
<span class="fc" id="L80">		}</span>
<span class="fc" id="L81">	 }</span>
		
	/** Constructs this component as a copy of the specified IS `s`.
	* Only structures (conataining reference of indexed elements) are copied.
	* @param s the IS to be copied 
	*/	
<span class="fc" id="L87">	public IS(IS s) {</span>
<span class="fc" id="L88">		this.sigma = new TreeSet&lt;Rule&gt;(s.getRules());</span>
<span class="fc" id="L89">		this.S = new TreeSet&lt;Comparable&gt;(s.getSet());</span>
<span class="fc" id="L90">	}	</span>
	/** Constructs this component from the specified file.
	*	
	* The file have to respect a certain format :
	*
     * An implicational system can be instancied from and save to a text file in the following format:
     * A list of elements separated by a space in the first line ;
     * then, each rule on a line, written like [premise] -&gt; [conclusion]
     * where elements are separated by a space.
     *
     *     a b c d e
     *     a b -&gt; c d
     *     c d -&gt; e
     *
     * Each element must be declared on the first line, otherwise, it is not added in the rule
	* Each rule must have a non empty concusion, otherwise, it is not added in the component
	* @param filename the name of the file
	*/
<span class="nc" id="L108">	public IS (String filename) {</span>
		try {
<span class="nc" id="L110">			this.sigma = new TreeSet&lt;Rule&gt;(); </span>
<span class="nc" id="L111">			this.S = new TreeSet&lt;Comparable&gt;();</span>
<span class="nc" id="L112">			BufferedReader fichier = new BufferedReader(new FileReader(filename));						</span>
			// first line : All elements of S separated by a space
			// a StringTokenizer is used to divide the line into different token,
            // considering spaces as separator.
<span class="nc" id="L116">			StringTokenizer st =  new StringTokenizer(fichier.readLine());	</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">			while (st.hasMoreTokens()) {</span>
<span class="nc" id="L118">                String n = new String (st.nextToken());			</span>
<span class="nc" id="L119">				this.addElement(n);</span>
<span class="nc" id="L120">				}  </span>
			// next lines : [elements of the premise separated by a space] -&gt; [elements of the conclusion separated by a space]
			// a StringTokenizer is used to divide each rule. 
			String line;
<span class="nc bnc" id="L124" title="All 4 branches missed.">			while ((line = fichier.readLine())!=null &amp;&amp; !line.isEmpty()) {</span>
<span class="nc" id="L125">				st = new StringTokenizer(line);</span>
<span class="nc" id="L126">				Rule r = new Rule();</span>
<span class="nc" id="L127">				boolean prem = true;</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">				while (st.hasMoreTokens()) {</span>
<span class="nc" id="L129">					String word = st.nextToken();</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">					if (word.equals(&quot;-&gt;&quot;)) prem = false;</span>
					else {
<span class="nc" id="L132">                        String x = null;						</span>
						// search of x in S 
<span class="nc bnc" id="L134" title="All 2 branches missed.">						for (Comparable e : this.S)</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">                            if (((String)e).equals(word)) x = (String)e;							</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">						if (x!=null) </span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">							if (prem) r.addToPremise(x);</span>
<span class="nc" id="L138">							else r.addToConclusion(x);	</span>
					}
<span class="nc" id="L140">				}</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">				if (!r.getConclusion().isEmpty()) this.addRule(r); }</span>
<span class="nc" id="L142">		fichier.close(); }</span>
<span class="nc" id="L143">		catch (Exception e) { e.printStackTrace(); }</span>
<span class="nc" id="L144">	}</span>

	/* ------------- ACCESSORS METHODS ------------------ */
  /** Generates a random IS with a specified number of nodes and rules
	 @param nbS the number of nodes of the generated IS
     @param nbR the number of rules of the generated IS
	  **/
    public static IS randomIS(int nbS, int nbR) {
<span class="nc" id="L152">	IS Sigma = new IS();</span>
	// addition of elements
<span class="nc bnc" id="L154" title="All 2 branches missed.">	for (int i=1; i&lt;nbS; i++) {</span>
<span class="nc" id="L155">		Sigma.addElement(new Integer(i));</span>
		}
	// addition of rules
<span class="nc bnc" id="L158" title="All 2 branches missed.">	for (int i=1; i&lt;nbR; i++) {            </span>
<span class="nc" id="L159">            ComparableSet conclusion = new ComparableSet();</span>
<span class="nc" id="L160">            int choice = (int) Math.rint (nbS*Math.random());</span>
<span class="nc" id="L161">            int j=1;</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">            for (Comparable c : Sigma.getSet()) {                </span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">                if (j==choice)</span>
<span class="nc" id="L164">                    conclusion.add(c);</span>
<span class="nc" id="L165">                j++;</span>
<span class="nc" id="L166">            }</span>
<span class="nc" id="L167">            ComparableSet premisse = new ComparableSet();</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">            for (Comparable c : Sigma.getSet()) {</span>
<span class="nc" id="L169">                choice = (int) Math.rint (nbS*Math.random());                </span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">                if (choice &lt; nbS/5)</span>
<span class="nc" id="L171">                    premisse.add(c);                </span>
<span class="nc" id="L172">            }</span>
<span class="nc" id="L173">            Sigma.addRule(new Rule(premisse,conclusion));</span>
		}
<span class="nc" id="L175">		return Sigma;</span>
 	   }

	/* ------------- ACCESSORS METHODS ------------------ */
	
	/** Returns the set of rules 	*/	
<span class="fc" id="L181">	public TreeSet&lt;Rule&gt; getRules() { return this.sigma; }		</span>
	/** Returns the set of indexed elements 	*/	
<span class="fc" id="L183">	public TreeSet&lt;Comparable&gt; getSet() { return this.S; }</span>
	/** Returns the number of elements in the set S of this component	*/		
<span class="nc" id="L185">	public int nbElements() { return this.S.size(); }</span>
	/** Returns the number of rules of this component	*/		
<span class="fc" id="L187">	public int nbRules() { return this.sigma.size(); }</span>
	
	/* ------------- MODIFICATION METHODS ------------------ */	
		
	/** Adds the specified element to the set `S` of this component 
	* @param  e the comparable to be added
	* @return true if the element has been added to `S`
	*/
	public boolean addElement(Comparable e) {
<span class="nc" id="L196">		return S.add(e);</span>
	}
	/** Adds the specified element to the set `S` of this component 
	* @param  X the treeset of comparable to be added
	* @return true if the element has been added to `S`
	*/
	public boolean addAllElements(TreeSet&lt;Comparable&gt; X) {
<span class="nc" id="L203">		boolean all = true;</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">		for (Comparable e : X)</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">			if (!S.add(e)) </span>
<span class="nc" id="L206">				all=false;</span>
<span class="nc" id="L207">		return all;	</span>
	}
	 
	/** Delete the specified element from the set `S` of this component
	* and from all the rule containing it.
	* @param e the comparable to be added
	* @return true if the element has been added to `S`
	*/
	public boolean deleteElement(Comparable e) {
<span class="nc bnc" id="L216" title="All 2 branches missed.">		if (S.contains(e)) {</span>
<span class="nc" id="L217">			S.remove(e);</span>
<span class="nc" id="L218">			IS sauv = new IS(this);</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">			for (Rule r: sauv.sigma) {</span>
<span class="nc" id="L220">				Rule new_r = new Rule(r.getPremise(),r.getConclusion());</span>
<span class="nc" id="L221">				new_r.removeFromPremise(e);</span>
<span class="nc" id="L222">				new_r.removeFromConclusion(e);</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">				if (!r.equals(new_r)) {</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">                    if (new_r.getConclusion().size()!=0)</span>
<span class="nc" id="L225">                        this.replaceRule(r,new_r);</span>
                    else
<span class="nc" id="L227">                        this.removeRule(r);</span>
				}
<span class="nc" id="L229">            }</span>
<span class="nc" id="L230">			return true;	</span>
			}
<span class="nc" id="L232">		return false;</span>
	} 
	
	/** Checks if the set S of this component contains the elements of the specified rule 
	* @param r the rule to be checked 
	* @return true if `S` contains all the elements of the rule 
	*/
	public boolean checkRuleElements(Rule r)	{
<span class="nc bnc" id="L240" title="All 4 branches missed.">		for (Object e : r.getPremise()) if (!S.contains(e)) return false;</span>
<span class="nc bnc" id="L241" title="All 4 branches missed.">		for (Object e : r.getConclusion()) if (!S.contains(e)) return false;</span>
<span class="nc" id="L242">		return true;</span>
	}
	
	/** Checks if this component already contains the specified rule
	*
	* Rules are compared according to their premise and conclusion 
	* @param r the rule to be tested
	* @return true if `sigma` contains the rule
	*/
	public boolean containsRule(Rule r) {        
<span class="nc" id="L252">        return this.sigma.contains(r);</span>
	}
	
	/** Adds the specified rule to this component 
	* @param r the rule to be added
	* @return true the rule has been added to if `sigma`
	*/	
	public boolean addRule(Rule r) {
<span class="nc bnc" id="L260" title="All 4 branches missed.">		if (!this.containsRule(r) &amp;&amp; this.checkRuleElements(r)) </span>
<span class="nc" id="L261">			return this.sigma.add(r);</span>
<span class="nc" id="L262">		return false;</span>
	}
	
	/** Removes the specified rule from the set of rules of this component
	* @param r the rule to be removed
	* @return true if the rule has been removed 
	*/	
	public boolean removeRule(Rule r) {
<span class="nc" id="L270">    	return this.sigma.remove(r);</span>
	}

	/** Replaces the first specified rule by the second one
	* @param r1 the rule to be replaced by `r2`
	* @return true the rule has been replaced
	*/	
	public boolean replaceRule(Rule r1, Rule r2) {
<span class="nc bnc" id="L278" title="All 4 branches missed.">		return (this.removeRule(r1) &amp;&amp; this.addRule(r2));</span>
	}

	/*-----------  SAVING METHODS -------------------- */

	/** Returns a string representation of this component.
     * The following format is used:
     *
	 * An implicational system can be instancied from and save to a text file in the following format:
     * A list of elements separated by a space in the first line ;
     * then, each rule on a line, written like [premise] -&gt; [conclusion]
     * where elements are separated by a space.
     *
     *     a b c d e
     *     a b -&gt; c d
     *     c d -&gt; e
     *
    */
    public String toString()	{
<span class="fc" id="L297">        StringBuffer s = new StringBuffer();</span>
        // first line : All elements of S separated by a space
		// a StringTokenizer is used to delete spaces in the
        // string description of each element of S
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">	for (Comparable e : this.S) {</span>
<span class="nc" id="L302">            StringTokenizer st = new StringTokenizer(e.toString());</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">            while (st.hasMoreTokens())</span>
<span class="nc" id="L304">                s.append(st.nextToken());</span>
<span class="nc" id="L305">		s.append(&quot; &quot;);</span>
<span class="nc" id="L306">            }</span>
<span class="fc" id="L307">            s.append(&quot;\n&quot;);</span>
        // next lines : a rule on each line, described by:
        // [elements of the premise separated by a space] -&gt; [elements of the conclusion separated by a space]
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">	for (Rule r : this.sigma)</span>
<span class="nc" id="L311">            s.append(r.toString()).append(&quot;\n&quot;);</span>
<span class="fc" id="L312">	return s.toString();</span>
	}
	
	/** Saves this component in a file which name is specified.
     * The following format is used:
     *
     * An implicational system can be instancied from and save to a text file in the following format:
     * A list of elements separated by a space in the first line ;
     * then, each rule on a line, written like [premise] -&gt; [conclusion]
     * where elements are separated by a space.
     *
     *     a b c d e
     *     a b -&gt; c d
     *     c d -&gt; e
     *
	* @param filename the name of the file 
	*/
	public void toFile(String filename)	{
		try 	{
<span class="fc" id="L331">			BufferedWriter fichier = new BufferedWriter(new FileWriter(filename));</span>
<span class="fc" id="L332">			fichier.write(this.toString());</span>
<span class="fc" id="L333">            fichier.close();</span>
    	}
<span class="pc" id="L335">    	catch (Exception e) { e.printStackTrace(); } </span>
<span class="fc" id="L336">	}</span>

	/*-----------  PROPERTIES TEST METHODS -------------------- */
		
	/** Returns true if this component is a proper IS.
	*
	* This test is perfomed in O(|Sigma||S|) by testing conclusion of each rule
	*/
	public boolean isProper () {
<span class="nc bnc" id="L345" title="All 2 branches missed.">		for (Rule r : this.sigma) </span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">			if (r.getPremise().contains(r.getConclusion())) </span>
<span class="nc" id="L347">				return false;</span>
<span class="nc" id="L348">		return true;</span>
	}

	/** Returns true if this component is an unary IS.
	*
	* This test is perfomed in O(|Sigma||S|) by testing conclusion of each rule
	*/	
	public boolean isUnary () {
<span class="nc bnc" id="L356" title="All 2 branches missed.">		for (Rule r : this.sigma )</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">			if (r.getConclusion().size() &gt; 1 )</span>
<span class="nc" id="L358">				return false;</span>
<span class="nc" id="L359">		return true;</span>
	}

	/** Returns true if this component is a compact IS.
	*
	* This test is perfomed in O(|Sigma|^2|S|) by testing premises of each pair of rules
	*/	
	public boolean isCompact () {
<span class="nc bnc" id="L367" title="All 2 branches missed.">	 	for(Rule r1: this.sigma)</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">		    for(Rule r2: this.sigma) </span>
<span class="nc bnc" id="L369" title="All 4 branches missed.">			 	if (!r1.equals(r2) &amp;&amp; (r1.getPremise().equals(r2.getPremise()))) </span>
<span class="nc" id="L370">					return false;</span>
<span class="nc" id="L371">		return true;			</span>
	}	


	/** Returns true if conclusion of rules of this component are closed.
	*
	* This test is perfomed in O(|Sigma||S|) by testing conclusion of each rule
	*/	
		public boolean isRightMaximal () {
<span class="nc bnc" id="L380" title="All 2 branches missed.">		for (Rule r : this.sigma )</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">			if (!r.getConclusion().equals (this.closure(r.getConclusion())))</span>
<span class="nc" id="L382">				return false;</span>
<span class="nc" id="L383">		return true;</span>
	}

	/** Returns true if this component is left minimal.
	*
	* This test is perfomed in O(|Sigma|^2|S|) by testing conclusions of each pair of rules
	*/	
	public boolean isLeftMinimal () {
<span class="nc bnc" id="L391" title="All 2 branches missed.">		for (Rule r1 : this.sigma )</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">			for (Rule r2 : this.sigma )</span>
<span class="nc bnc" id="L393" title="All 6 branches missed.">			if (!r1.equals(r2) &amp;&amp; r1.getPremise().containsAll(r2.getPremise()) </span>
				&amp;&amp;r1.getConclusion().equals(r2.getConclusion()))
<span class="nc" id="L395">				return false;</span>
<span class="nc" id="L396">		return true;</span>
	}

	/** Returns true if this component is direct.
	* 
	* This test is perfomed in O(|Sigma|^2|S|) by testing if closure of 
	* the premisse of each conclusion can be obtained by only one iteration 
	* on the set of rules.
	*/	
	public boolean isDirect () {
<span class="nc bnc" id="L406" title="All 2 branches missed.">		for (Rule r1 : this.sigma ) {</span>
<span class="nc" id="L407">			TreeSet &lt;Comparable&gt; onePass = new TreeSet (r1.getPremise());</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">			for (Rule r2 : this.sigma) </span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">				if (r1.getPremise().containsAll(r2.getPremise()))</span>
<span class="nc" id="L410">					onePass.addAll (r2.getConclusion());</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">			if (!onePass.equals(this.closure(r1.getPremise())))			</span>
<span class="nc" id="L412">				return false;</span>
<span class="nc" id="L413">			}</span>
<span class="nc" id="L414">		return true;</span>
	}

	/** Returns true if this component is minimum.
	* 
	* This test is perfomed in O(|Sigma|^2|S|) by testing if closure of 
	* the premisse of each conclusion can be obtained by only one iteration 
	* on the set of rules.
	*/
	public boolean isMinimum () {
<span class="nc" id="L424">		IS tmp = new IS (this);</span>
<span class="nc" id="L425">		tmp.makeRightMaximal();</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">		for (Rule r : sigma ) {</span>
<span class="nc" id="L427">			 IS epsylon = new IS (tmp);</span>
<span class="nc" id="L428">		     epsylon.removeRule(r);</span>
<span class="nc" id="L429">			 TreeSet&lt;Comparable&gt; cl_this=this.closure(r.getPremise());</span>
<span class="nc" id="L430">			 TreeSet&lt;Comparable&gt; cl_epsilon=epsylon.closure(r.getPremise());</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">			 if (cl_this.equals(cl_epsilon))	</span>
<span class="nc" id="L432">			 	return false;</span>
<span class="nc" id="L433">			}</span>
<span class="nc" id="L434">		return true;</span>
	}

	/** Returns true if this component is equal to its canonical direct basis.
	*
	* The canonical direct basis is computed before to be compare with this component.
	*
	* This test is performed in O(d|S|), where d corresponds to the number of rules 
	* that have to be added by the direct treatment. This number is exponential in the worst case.
	*/	
	public boolean isCanonicalDirectBasis () {
<span class="nc" id="L445">		IS CDB = new IS (this);</span>
<span class="nc" id="L446">		CDB.makeCanonicalDirectBasis();</span>
<span class="nc bnc" id="L447" title="All 4 branches missed.">		if (this.isIncludedIn(CDB) &amp;&amp; CDB.isIncludedIn(this))</span>
<span class="nc" id="L448">			return true;</span>
<span class="nc" id="L449">		else return false;	</span>
	}
	
	/** Returns true if this component is equal to its canonical basis.
	*
	* The canonical basis is computed before to be compare with this component.
	*	
	* This treatment is performed in (|Sigma||S|cl) where O(cl) is the 
	* computation of a closure.
	*/	
	public boolean isCanonicalBasis () {
<span class="nc" id="L460">		IS CB = new IS (this);</span>
<span class="nc" id="L461">		CB.makeCanonicalBasis();</span>
<span class="nc bnc" id="L462" title="All 4 branches missed.">		if (this.isIncludedIn(CB) &amp;&amp; CB.isIncludedIn(this))</span>
<span class="nc" id="L463">			return true;</span>
<span class="nc" id="L464">		else return false;	</span>
	}

	/** Compares by inclusion of the proper and unary form of this component 
	* with the specified one.
	*
	* @param is another IS 
	* @return true the rule has been replaced
	*/	
	public boolean isIncludedIn(IS is) {
<span class="nc" id="L474">		IS tmp = new IS (this);</span>
<span class="nc" id="L475">		tmp.makeProper();</span>
<span class="nc" id="L476">		tmp.makeUnary();</span>
<span class="nc" id="L477">		is.makeProper();</span>
<span class="nc" id="L478">		is.makeUnary();</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">		for (Rule r : tmp.sigma) </span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">			if (!is.containsRule(r))</span>
<span class="nc" id="L481">				return false;</span>
<span class="nc" id="L482">		return true;	</span>
	}




	/*-----------  PROPERTIES MODIFICATION METHODS -------------------- */	
	
	/** Makes this component a proper IS.
	*
	* Elements that are at once in the conclusion and in the premise are deleted from the conclusion. 
	* When the obtained conclusion is an empty set, the rule is deleted from this component
	*
	* This treatment is performed in O(|Sigma||S|).
	* @return the difference between the number of rules of this component 
	* before and after this treatment
	*/
	public int makeProper ()	{
<span class="fc" id="L500">		IS sauv = new IS(this);			</span>
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">		for (Rule r : sauv.sigma) {</span>
			// deletes elements of conclusion which are in the premise
<span class="nc" id="L503">			Rule new_r = new Rule (r.getPremise(), r.getConclusion());			</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">			for (Object e : r.getConclusion())</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">				if (new_r.getPremise().contains(e)) </span>
<span class="nc" id="L506">					new_r.removeFromConclusion (e);</span>
			// replace the rule by the new rule is it has been modified
<span class="nc bnc" id="L508" title="All 2 branches missed.">			if (!r.equals(new_r)) this.replaceRule(r,new_r);</span>
			// delete rule with an empty conclusion
<span class="nc bnc" id="L510" title="All 2 branches missed.">			if (new_r.getConclusion().isEmpty())	</span>
<span class="nc" id="L511">				this.removeRule(new_r);</span>
<span class="nc" id="L512">			}</span>
<span class="fc" id="L513">		return sauv.nbRules()-this.nbRules();</span>
		}	
		
	/** Makes this component an unary IS.
	*
	* This treatment is performed in O(|Sigma||S|)
	*
	* A rule with a non singleton as conclusion is replaced with a sets of rule, one rule for each 
	* element of the conclusion.
	*
	* This treatment is performed in O(|Sigma||S|).	
	* @return the difference between the number of rules of this component 
	* before and after this treatment
	*/
	public int makeUnary () {
<span class="nc" id="L528">		IS sauv = new IS(this);		</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">		for (Rule r : sauv.sigma) {</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">			if (r.getConclusion().size()&gt;1){                </span>
<span class="nc" id="L531">				this.removeRule(r);</span>
<span class="nc" id="L532">                TreeSet&lt;Comparable&gt; conclusion = r.getConclusion();</span>
<span class="nc" id="L533">				TreeSet&lt;Comparable&gt; premise = r.getPremise();</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">				for (Comparable e : conclusion) {</span>
<span class="nc" id="L535">					TreeSet&lt;Comparable&gt; new_c = new TreeSet();</span>
<span class="nc" id="L536">					new_c.add(e);</span>
<span class="nc" id="L537">					Rule nr = new Rule (premise, new_c);</span>
<span class="nc" id="L538">					this.addRule(nr);                </span>
<span class="nc" id="L539">					}</span>
				}
<span class="nc" id="L541">			}</span>
<span class="nc" id="L542">		return sauv.nbRules()-this.nbRules();</span>
		}
		
	/** Replaces rules of same premise by only one rule.
	*
	* This treatment is performed in O(|sigma|^2|S|)
	*
	* @return the difference between the number of rules of this component 
	* before and after this treatment
	*/
    public int makeCompact(){        
<span class="fc" id="L553">		IS sauv = new IS(this);</span>
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">        for(Rule r1: sauv.sigma){</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">            if (this.containsRule(r1)) {</span>
<span class="nc" id="L556">		 	ComparableSet new_conc = new ComparableSet();            </span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">		    for(Rule r2: sauv.sigma) {                </span>
<span class="nc bnc" id="L558" title="All 6 branches missed.">			 	if (this.containsRule(r2) &amp;&amp; !r1.equals(r2) &amp;&amp; (r1.getPremise().equals(r2.getPremise()))) {</span>
<span class="nc" id="L559">					new_conc.addAll(r2.getConclusion());                    </span>
<span class="nc" id="L560">					boolean res = this.sigma.remove(r2);</span>
					}
<span class="nc" id="L562">				}</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">			 if (new_conc.size()&gt;0) {</span>
<span class="nc" id="L564">				new_conc.addAll(r1.getConclusion());</span>
<span class="nc" id="L565">				Rule new_r = new Rule (r1.getPremise(),new_conc);</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">                if (!r1.equals(new_r))</span>
<span class="nc" id="L567">				this.replaceRule(r1,new_r);                </span>
	          }                            
           }
<span class="nc" id="L570">	    }</span>
<span class="fc" id="L571">		return sauv.nbRules()-this.nbRules();							</span>
    	}

	/** Replaces conclusion of each rule with their closure without the premise.
	*
	* This treatment is performed in O(|sigma||S|cl), where O(cl) is the 
	* computation of a closure.
	* @return the difference between the number of rules of this component 
	* before and after this treatment
	*/
    public int makeRightMaximal(){    
<span class="fc" id="L582">		int s = this.nbRules();</span>
<span class="fc" id="L583">		this.makeCompact();</span>
<span class="fc" id="L584">		IS sauv = new IS(this);	</span>
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">		for(Rule r: sauv.sigma){									</span>
<span class="nc" id="L586">           Rule new_r= new Rule(r.getPremise(), this.closure(r.getPremise()));</span>
<span class="nc" id="L587">			  new_r.removeAllFromConclusion(new_r.getPremise());</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">			  if (!r.equals(new_r)) </span>
<span class="nc" id="L589">			  		this.replaceRule(r, new_r);</span>
<span class="nc" id="L590">       }</span>
<span class="fc" id="L591">		return s-this.nbRules();</span>
    	}

	/** Makes this component a left minimal and compact IS.
	*
	* The unary form of this componant is first computed: if two rules have the 
	* same unary conclusion, the rule with the inclusion-maximal premise is deleted.
	*
	* Then, the left-minimal treatment is performed in O(|sigma|^2|S|))
	*	
	* @return the difference between the number of rules of this component 
	* before and after this treatment
	*/
    public int makeLeftMinimal(){    
<span class="nc" id="L605">	 	this.makeUnary();</span>
<span class="nc" id="L606">		IS sauv = new IS(this);		</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">    	for(Rule r1: sauv.sigma)</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">        for(Rule r2: sauv.sigma)</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">            if (!r1.equals(r2))</span>
<span class="nc bnc" id="L610" title="All 4 branches missed.">                    if( (r2.getPremise().containsAll(r1.getPremise()) )</span>
						  &amp;&amp;(r1.getConclusion().equals(r2.getConclusion())) )
<span class="nc" id="L612">                        this.sigma.remove(r2);</span>
<span class="nc" id="L613">		this.makeCompact();						</span>
<span class="nc" id="L614">		return sauv.nbRules()-this.nbRules();</span>
    	}	

	/** Makes this component a compact and direct IS.
	*
	* The unary and proper form of this componant is first computed. 
	* For two given rules r1 and r2, if the conclusion of r1 contains the premise of r1, 
	* then a new rule is addes, with r1.premisse + r2.premisse - r1.conclusion as premise, and 
	* r2.conclusion as conlusion. This treatment is performed in a recursive way until no new rule
	* is added.
	*
	* This treatment is performed in O(d|S|), where d  corresponds to the number of rules 
	* that have to be added by the direct treatment, that can be exponential in the worst case.
	* @return the difference between the number of rules of this component 
	* before and after this treatment
	*/ 	
    public int makeDirect(){
<span class="nc" id="L631">	 	this.makeUnary();</span>
<span class="nc" id="L632">		this.makeProper();</span>
<span class="nc" id="L633">		int s = this.nbRules();</span>
<span class="nc" id="L634">		boolean ok = true;</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">		while (ok) {</span>
<span class="nc" id="L636">		IS sauv = new IS(this);		</span>
<span class="nc bnc" id="L637" title="All 2 branches missed."> 	     	for(Rule r1: sauv.sigma) </span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">                for(Rule r2: sauv.sigma)</span>
<span class="nc bnc" id="L639" title="All 4 branches missed.">                    if (!r1.equals(r2) &amp;&amp; !r1.getPremise().containsAll(r2.getConclusion()))	{		</span>
<span class="nc" id="L640">                    ComparableSet  C = new ComparableSet(r2.getPremise());</span>
<span class="nc" id="L641">                    C.removeAll(r1.getConclusion());</span>
<span class="nc" id="L642">                    C.addAll(r1.getPremise());</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">                    if (!C.containsAll(r2.getPremise())) {						</span>
<span class="nc" id="L644">                        Rule new_r  = new Rule(C,r2.getConclusion());</span>
                  /*new_r.addAllToPremise (r1.getPremise());
                  new_r.addAllToPremise (r2.getPremise());						
						new_r.removeAllFromPremise(r1.getConclusion());
						new_r.addAllToConclusion(r2.getConclusion() );*/
<span class="nc" id="L649">                  this.addRule(new_r);</span>
						
                  }
					}

<span class="nc bnc" id="L654" title="All 2 branches missed.">				if (this.nbRules() == sauv.nbRules())</span>
<span class="nc" id="L655">					ok=false;</span>
<span class="nc" id="L656">				}	</span>
<span class="nc" id="L657">		this.makeCompact();							  </span>
<span class="nc" id="L658">		return s-this.nbRules();</span>
      }

	/** Makes this component a minimum and proper IS.
	*
	* A rule is deleted when the closure of its premisse remains the same 
	* even if this rule is suppressed.
	*
	* This treatment is performed in O(|sigma||S|cl) where O(cl) is the 
	* computation of a closure.
	* @return the difference between the number of rules of this component 
	* before and after this treatment
	*/    
    public int makeMinimum(){	
<span class="fc" id="L672">		this.makeRightMaximal();</span>
<span class="fc" id="L673">		IS sauv = new IS(this);				</span>
<span class="pc bpc" id="L674" title="1 of 2 branches missed.">      for(Rule r: sauv.sigma){</span>
<span class="nc" id="L675">          IS epsylon= new IS(this);</span>
<span class="nc" id="L676">          epsylon.removeRule(r);       </span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">          if(epsylon.closure(r.getPremise()).equals(this.closure(r.getPremise()))) </span>
<span class="nc" id="L678">             this.removeRule(r);</span>
<span class="nc" id="L679">      }                </span>
<span class="fc" id="L680">		return sauv.nbRules()-this.nbRules();			 		</span>
    }

	/** Replace this component by its canonical direct basis.
	*
	* The proper, unary and left minimal form of this component is first computed,
	* before to apply the recursive directe treatment, then the left minimal treatment.
	*
	* This treatment is performed in O(d), where d corresponds to the number of rules 
	* that have to be added by the direct treatment. This number is exponential in the worst case.
	* @return the difference between the number of rules of this component 
	* before and after this treatment
	*/
    public int makeCanonicalDirectBasis(){
<span class="nc" id="L694">      int s = this.nbRules();</span>
<span class="nc" id="L695">      this.makeProper();     </span>
<span class="nc" id="L696">      this.makeLeftMinimal();</span>
<span class="nc" id="L697">      this.makeDirect();</span>
<span class="nc" id="L698">      this.makeLeftMinimal();</span>
<span class="nc" id="L699">      this.makeCompact();</span>
<span class="nc" id="L700">      return s-this.nbRules();</span>
   }

	/** Replace this component by the canonical basis.
	*	
	* Conclusion of each rule is first replaced by its closure. 
	* Then, premise of each rule r is replaced by its closure in IS \ r.
	*
	* This treatment is performed in (|Sigma||S|cl) where O(cl) is the 
	* computation of a closure.
	* @return the difference between the number of rules of this component 
	* before and after this treatment
	*/
   public int makeCanonicalBasis(){
<span class="fc" id="L714">		this.makeMinimum();</span>
<span class="fc" id="L715">		IS sauv = new IS(this);				</span>
<span class="pc bpc" id="L716" title="1 of 2 branches missed.">      for(Rule r: sauv.sigma){</span>
<span class="nc" id="L717">         IS epsylon= new IS(this);</span>
<span class="nc" id="L718">         epsylon.removeRule(r);</span>
<span class="nc" id="L719">         Rule tmp= new Rule(epsylon.closure(r.getPremise()),r.getConclusion() );         </span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">			if (!r.equals (tmp))</span>
<span class="nc" id="L721">         this.replaceRule(r,tmp);</span>
<span class="nc" id="L722">        }</span>
<span class="fc" id="L723">		this.makeProper();</span>
<span class="fc" id="L724">		return sauv.nbRules()-this.nbRules();</span>
   }

   /* --------------- METHODS BASED ON GRAPH ------------ */

	/** Returns the representative graph of this component.
	*
	* Nodes of the graph are attributes of this components.
	* For each proper rule X+b-&gt;a, there is an {X}-valuated edge from a to b.
    * Notice that, for a rule b-&gt;a, the edge from a to b is valuated by emptyset.
     * and for the two rules X+b-&gt;a and Y+b-&gt;a, the edge from a to b is valuated by {X,Y}.
     * @return the representative graph of this component.
	*/
	public DGraph representativeGraph () {
<span class="nc" id="L738">        IS tmp = new IS (this);</span>
<span class="nc" id="L739">        tmp.makeUnary();</span>
		// nodes of the graph are elements not belonging to X
<span class="nc" id="L741">		DGraph pred = new DGraph();</span>
<span class="nc" id="L742">        TreeMap&lt;Comparable,Node&gt; nodeCreated = new TreeMap&lt;Comparable,Node&gt;();</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">		for (Comparable x : tmp.getSet()) {</span>
<span class="nc" id="L744">            Node n = new Node(x);</span>
<span class="nc" id="L745">			pred.addNode (n);</span>
<span class="nc" id="L746">            nodeCreated.put(x, n);</span>
<span class="nc" id="L747">        }</span>
		// an edge is added from b to a when there exists a rule X+a -&gt; b or a -&gt; b
<span class="nc bnc" id="L749" title="All 2 branches missed.">		for (Rule r : tmp.getRules()) {</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">			for (Comparable a : r.getPremise()) {</span>
<span class="nc" id="L751">                ComparableSet diff = new ComparableSet(r.getPremise());</span>
<span class="nc" id="L752">                diff.remove(a);                </span>
<span class="nc" id="L753">				Node from = nodeCreated.get(r.getConclusion().first());</span>
<span class="nc" id="L754">				Node to = nodeCreated.get(a);</span>
                Edge ed;
<span class="nc bnc" id="L756" title="All 2 branches missed.">                if (pred.containsEdge(from, to))</span>
<span class="nc" id="L757">                   ed = pred.getEdge(from,to);</span>
                else {
<span class="nc" id="L759">                   ed = new Edge (from,to,new TreeSet&lt;ComparableSet&gt;());</span>
<span class="nc" id="L760">                   pred.addEdge(ed);</span>
                }
<span class="nc" id="L762">                ((TreeSet&lt;ComparableSet&gt;)ed.getContent()).add(diff);</span>
<span class="nc" id="L763">				}</span>
<span class="nc" id="L764">			}</span>
<span class="nc" id="L765">		return pred;</span>
	}
	/** Returns the dependance graph of this component.
	 *
     * Dependance graph of this component is the representative
     * graph of the canonical direct basis.
     * Therefore, the canonical direct basis has to be generated before
     * to compute its representativ graph, and
     * this treatment is performed in O(d), as for the canonical direct basis generation,
     * where d corresponds to the number of rules
	* that have to be added by the direct treatment. This number is exponential in the worst case.
     *
     * * @return the dependance graph of this component.
	*/
	public DGraph dependanceGraph () {
<span class="nc" id="L780">		IS BCD = new IS (this);</span>
<span class="nc" id="L781">		BCD.makeCanonicalDirectBasis();</span>
<span class="nc" id="L782">		BCD.makeUnary();</span>
<span class="nc" id="L783">		return BCD.representativeGraph();</span>
	}

    /** Removes from this component reducible elements.
    *
    * Reducible elements are elements equivalent by closure to others elements.   
    * They are computed by `getReducibleElements` of `ClosureSystem` 
    * in O(O(|Sigma||S|^2)
    * @return the set of reducibles removed elements, with their equivalent elements
    */
    public TreeMap &lt;Comparable, TreeSet&lt;Comparable&gt;&gt; reduction () {
        // compute the reducible elements            
<span class="nc" id="L795">        TreeMap Red = this.getReducibleElements();            </span>
        // modify each rule
<span class="nc bnc" id="L797" title="All 2 branches missed.">        for (Object x : Red.keySet()) {</span>
<span class="nc" id="L798">            TreeSet &lt;Rule&gt; rules = this.getRules();</span>
<span class="nc" id="L799">            rules = (TreeSet&lt;Rule&gt;) rules.clone();            </span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">            for (Rule r : rules) {                </span>
<span class="nc" id="L801">                Rule r2 = new Rule();</span>
<span class="nc" id="L802">                boolean modif = false;</span>
                // replace the reducible element by its equivalent in the premise
<span class="nc" id="L804">                TreeSet premise = r.getPremise();</span>
<span class="nc" id="L805">                premise = (TreeSet) premise.clone();</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">                if (premise.contains(x)) {</span>
<span class="nc" id="L807">                    premise.remove(x);</span>
<span class="nc" id="L808">                    premise.addAll((TreeSet)Red.get(x));</span>
<span class="nc" id="L809">                    r2.addAllToPremise(premise);</span>
<span class="nc" id="L810">                    modif = true;</span>
                } 
<span class="nc" id="L812">                else r2.addAllToPremise(premise);                </span>
                // replace the reducible element by its equivalent in the conclusion
<span class="nc" id="L814">                TreeSet conclusion = r.getConclusion();</span>
<span class="nc" id="L815">                conclusion = (TreeSet) conclusion.clone();</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">                if (conclusion.contains(x)) {</span>
<span class="nc" id="L817">                    conclusion.remove(x);</span>
<span class="nc" id="L818">                    conclusion.addAll((TreeSet)Red.get(x));</span>
<span class="nc" id="L819">                    r2.addAllToConclusion(conclusion);</span>
<span class="nc" id="L820">                    modif = true;</span>
                }    
<span class="nc" id="L822">                else r2.addAllToConclusion(conclusion);                </span>
                // replace the rule if modified
<span class="nc bnc" id="L824" title="All 2 branches missed.">                if (modif)</span>
<span class="nc" id="L825">                    this.replaceRule(r, r2);</span>
<span class="nc" id="L826">            }</span>
            // remove the reducible elements from the elements set
<span class="nc" id="L828">            this.deleteElement((Comparable)x);                        </span>
<span class="nc" id="L829">        }</span>
<span class="nc" id="L830">        return Red;</span>
    }

	/* --------------- IMPLEMENTATION OF CLOSURESYSTEM ABSTRACT METHODS ------------ */

	/**  Builds the closure of a set X of indexed elements.
	*
	* The closure is initialized with X. The closure is incremented with 
	* the conclusion of each rule whose premise is included in it. 
	* Iterations over the rules are performed until no new elemnet has to be added 
	* in the closure.
	*
	* For direct IS, only one iteration is needed, and the treatment is 
	* performed in O(|Sigma||S|).
	*
	* For non direct IS, at most |S| iterations are needed, and this tratment
	* is performed in O(|Sigma||S|^2).
	* @param X a TreeSet of indexed elements
	* @return  the closure of X for this component 
	*/
	public TreeSet&lt;Comparable&gt; closure (TreeSet&lt;Comparable&gt; X) {
<span class="fc" id="L851">		TreeSet&lt;Comparable&gt; oldES = new TreeSet&lt;Comparable&gt;();</span>
		// all the attributes are in their own closure
<span class="fc" id="L853">		TreeSet&lt;Comparable&gt; newES = new TreeSet&lt;Comparable&gt;(X);</span>
        do {
<span class="fc" id="L855">			oldES.addAll(newES);		</span>
<span class="fc bfc" id="L856" title="All 2 branches covered.">			for (Rule r : this.sigma) {</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">				if (newES.containsAll(r.getPremise()))</span>
<span class="fc" id="L858">					newES.addAll(r.getConclusion());</span>
<span class="fc" id="L859">			}</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">		} while (!(oldES.equals(newES)));</span>
<span class="fc" id="L861">		return newES;</span>
	}
}	// end of IS
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312101107</span></div></body></html>