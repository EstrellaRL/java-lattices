<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Context.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Java Lattices</a> &gt; <a href="index.source.html" class="el_package">lattice</a> &gt; <span class="el_source">Context.java</span></div><h1>Context.java</h1><pre class="source lang-java linenums">package lattice;

/*
 * Context.java
 *
 * last update on March 2010
 *
 */
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.*;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Iterator;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.TreeSet;
import dgraph.Node;

/**
 * This class gives a standard representation for a context.
 * A context is a binary table, with attributes in column, and observations
 * in row.
 *
 * A context is composed of attributes, a treeset of comparable objects ;
 * observations, a treeset of comparable objects ; and a Galois connexion
 * (extent,intent) between objects and attributes where
 * `extent` is a TreeMap that associates to each attribute a TreeSet of observations and
 * `intent` is a TreeMap that associates  to each observation a TreeSet of attributes.
 *
 * This class provides methods implementing classical operation on a context:
 * closure, reduction, reverse, ...
 *
 * A context owns properties of a closure system, and thus extends the abstract class
 * `ClosureSystem` and implements methods `getS` and `closure`. 
 * Therefore, the closed set lattice of a context can be generated by invoking method `closedSetLattice` of a closure system.  
 * However, this class also provides a method generating the concept lattice of this component
 * by completing each closed set of the closed set lattice.
 *
 * A context can be instancied from and save to a text file in the following format:
 * The list of observations separated by a space on the first line ;
 * the list of attrbutes separated by a space on the second line ;
 * then, for each observations o, the list of its intent on a line, written like o a1 a2 ...
 *
 *     Observations: 1 2 3
 *     Attributes: a b c d e
 *     1 a c
 *     2 a b
 *     3 b d e
 *     4 c e
 *
 * Copyright: 2013 University of La Rochelle, France
 * License: http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html CeCILL-B license
 * This file is part of lattice, free package. You can redistribute it and/or modify
 * it under the terms of CeCILL-B license.
 * @author Karell Bertet
 * @version 2013
 */
public class Context extends ClosureSystem {

	/* ------------- FIELD ------------------ */	
	
	/** A set of observations **/
	protected TreeSet&lt;Comparable&gt; observations;
	/** A set of attributes **/
	protected TreeSet&lt;Comparable&gt; attributes;
	/** A map to associate a set of attributes to each observation */
	protected TreeMap&lt;Comparable,TreeSet&lt;Comparable&gt;&gt; intent;
	/** A map to associate a set of observations to each attribute */
	protected TreeMap&lt;Comparable,TreeSet&lt;Comparable&gt;&gt; extent;

//cguerin 2013-06-26 - Optimisation des calculs par BitSets
    /* ------------- BITSET ADDON ------------------ */
    
    private BitSet b_attributes;
    private BitSet b_obersavtions;
    private TreeMap&lt;Comparable,BitSet&gt; b_intent;
    private TreeMap&lt;Comparable,BitSet&gt; b_extent;
    ArrayList&lt;Comparable&gt; array_observations;
    ArrayList&lt;Comparable&gt; array_attributes;
    public int vari;
    //fin cguerin
	/* ------------- CONSTRUCTORS ------------------ */	
	
  	/** Constructs a new empty context */
<span class="fc" id="L88">	public Context () {</span>
<span class="fc" id="L89">		this.observations = new TreeSet&lt;Comparable&gt;();</span>
<span class="fc" id="L90">		this.attributes = new TreeSet&lt;Comparable&gt;();</span>
<span class="fc" id="L91">		this.intent = new TreeMap&lt;Comparable,TreeSet&lt;Comparable&gt;&gt;();</span>
<span class="fc" id="L92">		this.extent = new TreeMap&lt;Comparable,TreeSet&lt;Comparable&gt;&gt;();</span>
<span class="fc" id="L93">        this.b_attributes = new BitSet();</span>
<span class="fc" id="L94">        this.b_obersavtions = new BitSet();</span>
<span class="fc" id="L95">        this.b_intent = new TreeMap();</span>
<span class="fc" id="L96">        this.b_extent = new TreeMap();</span>
<span class="fc" id="L97">        this.array_observations = new ArrayList();</span>
<span class="fc" id="L98">        this.array_attributes = new ArrayList();</span>
<span class="fc" id="L99">		}		</span>
  	/** Constructs a new context as a copy of the specified context */
<span class="nc" id="L101">    public Context (Context C) {</span>
<span class="nc" id="L102">        this.observations = new TreeSet();</span>
<span class="nc" id="L103">        this.attributes = new TreeSet();</span>
<span class="nc" id="L104">        this.intent = new TreeMap();</span>
<span class="nc" id="L105">        this.extent = new TreeMap();</span>



<span class="nc" id="L109">        this.b_attributes = new BitSet();</span>
<span class="nc" id="L110">        this.b_obersavtions = new BitSet();</span>
<span class="nc" id="L111">        this.b_intent = new TreeMap();</span>
<span class="nc" id="L112">        this.b_extent = new TreeMap();</span>
<span class="nc" id="L113">        this.array_observations = new ArrayList();</span>
<span class="nc" id="L114">        this.array_attributes = new ArrayList();</span>
        
        //cguerin - 2013-04-20 - add attributes and observation copy
<span class="nc" id="L117">        this.attributes.addAll(C.getAttributes());</span>
<span class="nc" id="L118">        this.observations.addAll(C.getObservations());</span>
        //fin cguerin

        //cguerin - 2013-04-20 - fix intent/extent inversion
<span class="nc bnc" id="L122" title="All 2 branches missed.">        for (Comparable o : C.getObservations()){</span>
<span class="nc" id="L123">            this.intent.put(o, new TreeSet(C.getIntent(o)));</span>
<span class="nc" id="L124">        }</span>

<span class="nc bnc" id="L126" title="All 2 branches missed.">        for (Comparable a : C.getAttributes()){                </span>
<span class="nc" id="L127">            this.extent.put(a, new TreeSet(C.getExtent(a)));</span>
<span class="nc" id="L128">        }</span>
        //fin cguerin
<span class="nc" id="L130">    }</span>
	
	/** Constructs this component from the specified file.
	*
	* The file have to respect a certain format :
	*
     * The list of observations separated by a space on the first line ;
     * the list of attrbutes separated by a space on the second line ;
     * then, for each observations o, the list of its intent on a line, written like o a1 a2 ...
     * 
     *     Observations: 1 2 3
     *     Attributes: a b c d e
     *     1 a c
     *     2 a b
     *     3 b d e
     *     4 c e
     *
     * Each observation must be declared on the first line, otherwise, it is not added
	* Each attribute must be declared on the second line, otherwise, it is not added
	* @param filename the name of the file
	*/
	public Context (String filename) {
<span class="nc" id="L152">		this();	</span>
		try {
<span class="nc" id="L154">			BufferedReader fichier = new BufferedReader(new FileReader(filename));						</span>
			// first line : All observations separated by a space
			// a StringTokenizer is used to divide the line into different observations
            // considering spaces as separator.
<span class="nc" id="L158">			StringTokenizer st =  new StringTokenizer(fichier.readLine());	</span>
<span class="nc" id="L159">			st.nextToken(); // first token corresponds to the string &quot;Observations:&quot;</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">			while (st.hasMoreTokens()) {</span>
<span class="nc" id="L161">				String n = new String (st.nextToken());</span>
<span class="nc" id="L162">				this.addToObservations(n);</span>
<span class="nc" id="L163">				}  </span>
			// second line : All attributes separated by a space
			// a StringTokenizer is used to divide the line into different token,
            // considering spaces as separator.
<span class="nc" id="L167">			st =  new StringTokenizer(fichier.readLine());	</span>
<span class="nc" id="L168">			st.nextToken(); // first token corresponds to the string &quot;Attributes:&quot;</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">			while (st.hasMoreTokens()) {</span>
<span class="nc" id="L170">				String n = new String (st.nextToken());</span>
<span class="nc" id="L171">				this.addToAttributes(n);</span>
<span class="nc" id="L172">				}  </span>
			// next lines : All intents of observations, one on each line: 
			// observation : list of attributes
			// a StringTokenizer is used to divide each intent.
			String line;
<span class="nc bnc" id="L177" title="All 4 branches missed.">			while ((line = fichier.readLine())!=null &amp;&amp; !line.isEmpty()) {                </span>
<span class="nc" id="L178">				st = new StringTokenizer(line);</span>
<span class="nc" id="L179">				String word = st.nextToken();</span>
<span class="nc" id="L180">				Comparable o = null;</span>
				// search of o in observations
<span class="nc bnc" id="L182" title="All 2 branches missed.">				for (Comparable e : this.getObservations())</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">						if (e.equals(word)) o=e;						</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">				if (o!=null) {</span>
<span class="nc" id="L185">					word = st.nextToken(); // this token corresponds to the sting &quot;:&quot;</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">					while (st.hasMoreTokens()) {</span>
<span class="nc" id="L187">						word = st.nextToken();</span>
<span class="nc" id="L188">						Comparable a = null;</span>
						// search of a in attributes 
<span class="nc bnc" id="L190" title="All 2 branches missed.">						for (Comparable e : this.getAttributes())</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">							if (e.equals(word)) a=e;																				</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">						if (a!=null) </span>
<span class="nc" id="L193">							this.addExtentIntent(o,a);</span>
<span class="nc" id="L194">					}</span>
				}	
<span class="nc" id="L196">			}				</span>
<span class="nc" id="L197">		fichier.close(); }</span>
<span class="nc" id="L198">		catch (Exception e) { e.printStackTrace(); }</span>
<span class="nc" id="L199">	}</span>

	/** This fonction just for read file of Dounia	  
     * The following format is respected: 
		 *
		 * For each observations o
		 * The name of observations separated on a line ;
		 * then, the list of frequence of each attrbutes intent on a line, written like a1 a2 ...
		 *
		 *     0002.png
		 *     0 0 0 3 0 0 3 0 0 0 0 0 6 0 5 3 11
		 *     0004.png
		 *     0 0 0 8 0 0 5 0 0 0 0 0 4 0 9 1 8
		 *     0007.png
		 *     0 0 0 3 0 0 4 0 0 0 0 0 27 0 3 4 9
		 *
     */
	public Context (String filename, int ThresholdBinary) {
<span class="nc" id="L217">		this();	</span>
		try {
<span class="nc" id="L219">			BufferedReader fichier = new BufferedReader(new FileReader(filename));						</span>
			String line;
<span class="nc bnc" id="L221" title="All 4 branches missed.">			while ((line = fichier.readLine()) != null &amp;&amp; !line.isEmpty()) { 				 </span>
				// first line : an observation             
<span class="nc" id="L223">				StringTokenizer st = new StringTokenizer(line); </span>
<span class="nc" id="L224">				String o = new String (st.nextToken());</span>
<span class="nc" id="L225">				this.addToObservations(o);</span>
				
				// second line : All attributes separated by a space
				// a StringTokenizer is used to divide the line into different token,
            // considering spaces as separator.
<span class="nc" id="L230">				line = fichier.readLine();</span>
<span class="nc" id="L231">				st = new StringTokenizer(line);</span>
<span class="nc" id="L232">				int IdAtt = 0;</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">				while (st.hasMoreTokens()) {</span>
<span class="nc" id="L234">					IdAtt += 1;</span>
<span class="nc" id="L235">					int a = Integer.parseInt(st.nextToken());</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">					if (a &gt; ThresholdBinary) {</span>
<span class="nc" id="L237">						this.addToAttributes(Integer.toString(IdAtt));</span>
<span class="nc" id="L238">						this.addExtentIntent(o,Integer.toString(IdAtt));</span>
					}
<span class="nc" id="L240">				}			</span>
<span class="nc" id="L241">			}				</span>
<span class="nc" id="L242">			fichier.close(); </span>
		}
<span class="nc" id="L244">		catch (Exception e) { e.printStackTrace(); }</span>
<span class="nc" id="L245">	}</span>
	
	// function for read all file in a folder in a context C (files Dounia)
	public Context(String link, TreeSet&lt;String&gt; filesname, int ThresholdBinary) {
<span class="nc" id="L249">		this();	</span>
		try {
<span class="nc bnc" id="L251" title="All 2 branches missed.">			for (String fileName : filesname){</span>
<span class="nc" id="L252">				BufferedReader fichier = new BufferedReader(new FileReader(link+fileName));						</span>
				String line;
<span class="nc bnc" id="L254" title="All 4 branches missed.">				while ((line = fichier.readLine()) != null &amp;&amp; !line.isEmpty()) { 				 </span>
					// first line : an observation             
<span class="nc" id="L256">					StringTokenizer st = new StringTokenizer(line); </span>
<span class="nc" id="L257">					String o = new String (st.nextToken());</span>
<span class="nc" id="L258">					this.addToObservations(o);</span>
					
					// second line : All attributes separated by a space
					// a StringTokenizer is used to divide the line into different token,
	            // considering spaces as separator.
<span class="nc" id="L263">					line = fichier.readLine();</span>
<span class="nc" id="L264">					st = new StringTokenizer(line);</span>
<span class="nc" id="L265">					int IdAtt = 0;</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">					while (st.hasMoreTokens()) {</span>
<span class="nc" id="L267">						IdAtt += 1;</span>
<span class="nc" id="L268">						int a = Integer.parseInt(st.nextToken());</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">						if (a &gt; ThresholdBinary) {</span>
<span class="nc" id="L270">							this.addToAttributes(Integer.toString(IdAtt));</span>
<span class="nc" id="L271">							this.addExtentIntent(o,Integer.toString(IdAtt));</span>
						}
<span class="nc" id="L273">					}			</span>
<span class="nc" id="L274">				}				</span>
<span class="nc" id="L275">				fichier.close();</span>
<span class="nc" id="L276">			}</span>
		}
<span class="nc" id="L278">		catch (Exception e) { e.printStackTrace(); }</span>
<span class="nc" id="L279">	}</span>
	/** This fonction just for read files of Van.
     * The following format is respected: 
		 *
		 * The name of observations is the name of files
		 * For each file (observations o)
		 * Each line present an attrbute: id with the frequence of him.
		 *
		 *     1000.png
		 *     0 0
		 *     1 0
		 *     2 1
		 *     ...
		 *     500 0
		 *
    */
	public Context ( TreeSet&lt;String&gt; linkFilesName, int ThresholdBinary) {
<span class="nc" id="L296">		this();	</span>
		try {
			// Read each file
<span class="nc bnc" id="L299" title="All 2 branches missed.">			for (String linkFileName : linkFilesName){</span>
				// add an observation =&gt; file name
<span class="nc" id="L301">				StringTokenizer st = new StringTokenizer(linkFileName,File.separator);</span>
<span class="nc" id="L302">				String fileName = &quot;&quot;;</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">				while (st.hasMoreTokens())</span>
<span class="nc" id="L304">					fileName = st.nextToken();</span>
				// remove .bow
<span class="nc" id="L306">				st = new StringTokenizer(fileName,&quot;.&quot;);</span>
<span class="nc" id="L307">				String o = st.nextToken() + &quot;.&quot; + st.nextToken();</span>
<span class="nc" id="L308">				this.addToObservations(o);</span>
				
				// add attributes
				// each line is an attribute
				// space is the sepaarator between id and value of attribute
<span class="nc" id="L313">				BufferedReader fichier = new BufferedReader(new FileReader(linkFileName));						</span>
				String line;
<span class="nc bnc" id="L315" title="All 4 branches missed.">				while ((line = fichier.readLine()) != null &amp;&amp; !line.isEmpty()) {				             </span>
<span class="nc" id="L316">					st = new StringTokenizer(line); </span>
<span class="nc" id="L317">					String id = st.nextToken();</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">					if(st.hasMoreTokens()) {</span>
<span class="nc" id="L319">						int value = Integer.parseInt(st.nextToken());</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">						if (value &gt; ThresholdBinary) {</span>
<span class="nc" id="L321">							this.addToAttributes(id);</span>
<span class="nc" id="L322">							this.addExtentIntent(o,id);</span>
						}
					}			
<span class="nc" id="L325">				}				</span>
<span class="nc" id="L326">				fichier.close(); </span>
<span class="nc" id="L327">			}</span>
		}
<span class="nc" id="L329">		catch (Exception e) { e.printStackTrace(); }</span>
<span class="nc" id="L330">	}</span>

        
	/* --------------- HANDLING METHODS FOR ATTRIBUTES AND OBSERVATIONS ------------ */	
				
   /** Returns the set of attributes of this component */
   public TreeSet&lt;Comparable&gt; getAttributes () {
<span class="fc" id="L337">		return this.attributes; }		</span>
	/** Checks if the specified attribute belong to this component */
	public boolean containsAttribute (Comparable att) {
<span class="fc" id="L340">		return this.attributes.contains(att); }</span>
	/** Checks if the specified set of attributes belong to this component */
	public boolean containsAllAttributes (TreeSet&lt;Comparable&gt; X) {
<span class="nc" id="L343">		return this.attributes.containsAll(X); }</span>
	/** Adds the specified element to the set of attributes of this component */	
	public boolean addToAttributes (Comparable att) {
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">		if (!this.containsAttribute(att)) </span>
<span class="fc" id="L347">			this.extent.put(att, new TreeSet&lt;Comparable&gt;());</span>
<span class="fc" id="L348">		return this.attributes.add(att); }</span>
	/** Adds the set of specified element to the set of attributes of this component */	
	public boolean addAllToAttributes (TreeSet&lt;Comparable&gt; X) {
<span class="nc" id="L351">		boolean all = true;</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">		for (Comparable att : X)</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">			if (!this.addToAttributes(att) )</span>
<span class="nc" id="L354">				all = false;</span>
<span class="nc" id="L355">		return all;	 }</span>
	/** Removes the specified element from the set of attributes of this component 
	* and from all the intents it belongs to */	
	public boolean removeFromAttributes (Comparable att) {
<span class="nc" id="L359">		this.extent.remove(att);</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">		for (Comparable o : this.getObservations())</span>
<span class="nc" id="L361">			this.intent.get(o).remove(att);</span>
<span class="nc" id="L362">		return this.attributes.remove(att); }</span>
		
   /** Returns the set of observations of this component */
   public TreeSet&lt;Comparable&gt; getObservations () {
<span class="fc" id="L366">		return this.observations; }</span>
	/** Checks if the specified observation belong to this component */
	public boolean containsObservation (Comparable obs) {
<span class="fc" id="L369">		return this.observations.contains(obs); }</span>
	/** Checks if the specified set of observations belong to this component */
	public boolean containsAllObservations (TreeSet&lt;Comparable&gt; X) {
<span class="nc" id="L372">		return this.observations.containsAll(X); }</span>
	/** Adds the specified element to the set of observations of this component */	
	public boolean addToObservations (Comparable obs) {
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">		if (!this.containsObservation(obs)) </span>
<span class="fc" id="L376">			this.intent.put(obs, new TreeSet&lt;Comparable&gt;());</span>
<span class="fc" id="L377">		return this.observations.add(obs); }</span>
	/** Adds the set of specified element to the set of observations of this component */	
	public boolean addAllToObservations (TreeSet&lt;Comparable&gt; X) {
<span class="nc" id="L380">		boolean all = true;</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">		for (Comparable obs : X)</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">			if (!this.addToObservations(obs)) </span>
<span class="nc" id="L383">				all = false;</span>
<span class="nc" id="L384">		return all;	 }</span>
		
	/** Removes the specified element from the set of observations of this component 
	* and from all the extents it belongs to */		
	public boolean removeFromObservations (Comparable obs) {
<span class="nc" id="L389">		this.intent.remove(obs);</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">		for (Comparable att : this.getAttributes())</span>
<span class="nc" id="L391">			this.extent.get(att).remove(obs);</span>
<span class="nc" id="L392">		return this.observations.remove(obs); }</span>
		
        //cguerin - 2013-06-28 - Setting of necessary variables for bitsets
        
        /*
         * Set the needed structures for the bitset optimization.
         * WARNING: this must be called each time your dataset change
         */
        public void setBitSets(){
<span class="nc" id="L401">            this.setMaps();</span>
<span class="nc" id="L402">            this.setBitSetsIntentExtent();</span>
<span class="nc" id="L403">        }</span>
        
        /*
         * Set the mapping structure for the bitset optimization
         */
        private void setMaps(){
<span class="nc" id="L409">            Iterator&lt;Comparable&gt; i = attributes.iterator();</span>
<span class="nc" id="L410">            int cpt = 0;</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            while(i.hasNext()){</span>
<span class="nc" id="L412">                Comparable c = i.next();</span>
<span class="nc" id="L413">                array_attributes.add(c);</span>
<span class="nc" id="L414">                ++cpt;</span>
<span class="nc" id="L415">            }</span>
            
<span class="nc" id="L417">            i = observations.iterator();</span>
<span class="nc" id="L418">            cpt=0;</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">            while(i.hasNext()){</span>
<span class="nc" id="L420">                Comparable c = i.next();</span>
<span class="nc" id="L421">                array_observations.add(c);</span>
<span class="nc" id="L422">                ++cpt;</span>
<span class="nc" id="L423">            }</span>
<span class="nc" id="L424">        }</span>
        
        /*
         * Set the extent and intent structures for the bitset optimization
         */
        private void setBitSetsIntentExtent(){
<span class="nc" id="L430">            Iterator&lt;Comparable&gt; i = attributes.iterator();</span>
<span class="nc" id="L431">            BitSet b = new BitSet(this.observations.size());</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">            while(i.hasNext()){</span>
<span class="nc" id="L433">                Comparable att = i.next();</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">                for(Comparable c : this.extent.get(att)){</span>
<span class="nc" id="L435">                    b.set(array_observations.indexOf(c));</span>
<span class="nc" id="L436">                }</span>
<span class="nc" id="L437">                b_extent.put(att, (BitSet)b.clone());</span>
<span class="nc" id="L438">                b.clear();</span>
<span class="nc" id="L439">            }</span>
<span class="nc" id="L440">            i = observations.iterator();</span>
<span class="nc" id="L441">            b = new BitSet(this.attributes.size());</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">            while(i.hasNext()){</span>
<span class="nc" id="L443">                Comparable obs = i.next();</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">                for(Comparable c : this.intent.get(obs)){</span>
<span class="nc" id="L445">                    b.set(array_attributes.indexOf(c));</span>
<span class="nc" id="L446">                }</span>
<span class="nc" id="L447">                b_intent.put(obs, (BitSet)b.clone());</span>
<span class="nc" id="L448">                b.clear();</span>
<span class="nc" id="L449">            }</span>
<span class="nc" id="L450">        }</span>
        
        //fin cguerin
	/* --------------- HANDLING METHODS FOR INTENT AND EXTENT ------------ */	
			
  	/** Returns the set of observations that are intent of the specified observation  */
  	public TreeSet&lt;Comparable&gt; getIntent (Comparable obs) {            
<span class="nc bnc" id="L457" title="All 2 branches missed.">            if (this.containsObservation(obs)){</span>
<span class="nc" id="L458">                return this.intent.get(obs);</span>
            }
            else {
<span class="nc" id="L461">                return new TreeSet&lt;Comparable&gt;();</span>

            } 
        }
  	/** Returns the set of observations that are all intent of attributes of the specified set */
        public TreeSet&lt;Comparable&gt; getIntent (TreeSet&lt;Comparable&gt; X) {                    
<span class="fc" id="L467">            TreeSet&lt;Comparable&gt; resIntent = new TreeSet&lt;Comparable&gt;(this.getAttributes());            </span>
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">            for (Comparable obs : X){</span>
<span class="nc" id="L469">                resIntent.retainAll(this.getIntent(obs));</span>
<span class="nc" id="L470">            }</span>
<span class="fc" id="L471">            return resIntent;            </span>
        }
	/** Checks if the second specified element is an intent of the first specified element */
	public boolean containAsIntent (Comparable obs, Comparable att ) {
<span class="nc bnc" id="L475" title="All 4 branches missed.">		if (this.containsObservation(obs) &amp;&amp; this.containsAttribute(att))</span>
<span class="nc" id="L476">			return this.intent.get(obs).contains(att);		</span>
<span class="nc" id="L477">		else return false; }		</span>

  	/** Returns the set of attributes that are intent of the specified observation  */
  	public TreeSet&lt;Comparable&gt; getExtent (Comparable att) {
<span class="nc bnc" id="L481" title="All 2 branches missed.">            if (this.containsAttribute(att)){</span>
<span class="nc" id="L482">                return this.extent.get(att);</span>
            }
            else {
<span class="nc" id="L485">                return new TreeSet&lt;Comparable&gt;();</span>

            } 
        }
  	/** Returns the set of attributes that are all intent of observations of the specified set */
  	public TreeSet&lt;Comparable&gt; getExtent (TreeSet&lt;Comparable&gt; X) {
<span class="fc" id="L491">            TreeSet&lt;Comparable&gt; ext = new TreeSet&lt;Comparable&gt;(this.getObservations());</span>
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">            for (Comparable att : X){</span>
<span class="nc" id="L493">                ext.retainAll(this.getExtent(att));</span>
<span class="nc" id="L494">            }</span>
<span class="fc" id="L495">            return ext;</span>
        }		
	public int getExtentNb (TreeSet&lt;Comparable&gt; X) {
<span class="fc" id="L498">            int size = this.getObservations().size();</span>
<span class="fc" id="L499">            BitSet b_resExtent = new BitSet(size);</span>
<span class="fc" id="L500">            b_resExtent.set(0, size);</span>
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">            for (Comparable att : X){</span>
                try{
<span class="nc" id="L503">                    b_resExtent.and(this.b_extent.get(att));</span>
                }
<span class="fc" id="L505">                catch(NullPointerException e){</span>
<span class="fc" id="L506">                    return 0;</span>
<span class="nc" id="L507">                }</span>
<span class="nc" id="L508">            }</span>
<span class="nc" id="L509">            return b_resExtent.cardinality();</span>
        }
	/** Checks if the second specified element is an intent of the first specified element */
	public boolean containAsExtent (Comparable att, Comparable obs ) {
<span class="nc bnc" id="L513" title="All 4 branches missed.">            if (this.containsObservation(obs) &amp;&amp; this.containsAttribute(att)){</span>
<span class="nc" id="L514">                return this.extent.get(att).contains(obs);		</span>

            }
            else {
<span class="nc" id="L518">                return false;</span>
            } 
        }	


	/** Adds the second specified element as intent of the first one, 
	* and the first one as extent of the second one.
	* The first one has to belong to the observations set 
	* and the second one to the attribute set.
	*/
	public boolean addExtentIntent (Comparable obs, Comparable att ) {
<span class="pc bpc" id="L529" title="2 of 4 branches missed.">		if (this.containsObservation(obs) &amp;&amp; this.containsAttribute(att))</span>
<span class="pc bpc" id="L530" title="2 of 4 branches missed.">			return this.intent.get(obs).add(att) &amp;&amp; this.extent.get(att).add(obs);</span>
<span class="nc" id="L531">		else return false; }		</span>
	/** Removes the second specified element from the intent of the first one, 
	* and the first one from the extent of the second one.
	* The first one has to belong to the observations set 
	* and the second one to the attribute set.
	*/
	public boolean removeExtentIntent (Comparable obs, Comparable att ) {
<span class="nc bnc" id="L538" title="All 4 branches missed.">		if (this.containsObservation(obs) &amp;&amp; this.containsAttribute(att))</span>
<span class="nc bnc" id="L539" title="All 4 branches missed.">			return this.intent.get(obs).remove(att) &amp;&amp; this.extent.get(att).remove(obs);</span>
<span class="nc" id="L540">		else return false; }		</span>

				
	/* --------------- CONTEXT HANDLING METHODS ------------ */		

	/** Returns a String representation of this component.
     * The following format is respected:
     *
	* The list of observations separated by a space on the first line ;
     * the list of attrbutes separated by a space on the second line ;
     * then, for each observations o, the list of its intent on a line, written like o a1 a2 ...
     *
     *     Observations: 1 2 3
     *     Attributes: a b c d e
     *     1 a c
     *     2 a b
     *     3 b d e
     *     4 c e
     */
	public String toString() {
<span class="fc" id="L560">            StringBuffer string = new StringBuffer ();</span>
<span class="fc" id="L561">            string.append (&quot;Observations: &quot;);</span>
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">            for (Comparable o : this.observations) {</span>
            // first line : All observations separated by a space
            // a StringTokenizer is used to delete spaces in the
            // string description of each observation
<span class="nc" id="L566">            StringTokenizer st = new StringTokenizer(o.toString());</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">            while (st.hasMoreTokens())</span>
<span class="nc" id="L568">                string.append(st.nextToken());</span>
<span class="nc" id="L569">		string.append(&quot; &quot;);</span>
<span class="nc" id="L570">		}</span>
<span class="fc" id="L571">            string.append(&quot;\nAttributes: &quot;);</span>
<span class="pc bpc" id="L572" title="1 of 2 branches missed.">            for (Comparable a : this.attributes) {</span>
            // second line : All attributes separated by a space
            // a StringTokenizer is used to delete spaces in the
            // string description of each observation
<span class="nc" id="L576">                StringTokenizer st = new StringTokenizer(a.toString());</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">                while (st.hasMoreTokens())</span>
<span class="nc" id="L578">                    string.append(st.nextToken());</span>
<span class="nc" id="L579">                    string.append(&quot; &quot;);</span>
<span class="nc" id="L580">		}</span>
		// next lines : All intents of observations, one on each line:
		// observation : list of attributes
		// a StringTokenizer is used to delete spaces in the
        // string description of each observation and attributes
<span class="fc" id="L585">		string.append(&quot;\n&quot;);</span>
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">		for (Comparable o : this.observations) {</span>
<span class="nc" id="L587">            StringTokenizer st = new StringTokenizer(o.toString());</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">            while (st.hasMoreTokens())</span>
<span class="nc" id="L589">                string.append(st.nextToken());</span>
<span class="nc" id="L590">		string.append(&quot; : &quot;);</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">		for (Comparable a : this.getIntent(o)) {</span>
<span class="nc" id="L592">                    st = new StringTokenizer(a.toString());</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">                while (st.hasMoreTokens())</span>
<span class="nc" id="L594">                    string.append(st.nextToken());		</span>
<span class="nc" id="L595">                string.append(&quot; &quot;);</span>
<span class="nc" id="L596">                }</span>
<span class="nc" id="L597">		string.append(&quot;\n&quot;);	</span>
<span class="nc" id="L598">		}</span>
<span class="fc" id="L599">		return string.toString();</span>
	}
	/** Saves this component in a text file which name is specified.
	*
     * The following format is respected:
     *
	* The list of observations separated by a space on the first line ;
     * the list of attrbutes separated by a space on the second line ;
     * then, for each observations o, the list of its intent on a line, written like o a1 a2 ...
     *
     *     Observations: 1 2 3
     *     Attributes: a b c d e
     *     1 a c
     *     2 a b
     *     3 b d e
     *     4 c e
     *
	* @param filename the name of the file 
	*/
	public void toFile(String filename)	{
		try 	{
<span class="fc" id="L620">			BufferedWriter fichier = new BufferedWriter(new FileWriter(filename));</span>
<span class="fc" id="L621">			fichier.write(this.toString());				</span>
<span class="fc" id="L622">            fichier.close();</span>
    	}
<span class="pc" id="L624">    	catch (Exception e) { e.printStackTrace(); } </span>
<span class="fc" id="L625">	}</span>
	
	/** Removes from this component reducible attributes.
	*
	* Reducible attributes are attributes equivalent by closure to others attributes.   
        * They are computed by `getReducibleElements` od `ClosureSystem` in O(|A|^3|O|)
	* @return the set of reducibles removed attributes, with their equivalent attributes
	*/
	public TreeMap &lt;Comparable, TreeSet&lt;Comparable&gt;&gt; attributesReduction () {
            // compute the reducible elements            
<span class="nc" id="L635">            TreeMap Red = this.getReducibleElements();            </span>
            // remove the reducible elements from the attributes set
<span class="nc bnc" id="L637" title="All 2 branches missed.">            for (Object att : Red.keySet()) </span>
<span class="nc" id="L638">                this.removeFromAttributes((Comparable)att);            </span>
<span class="nc" id="L639">            return Red;</span>
        }
         
        /** Removes from this component reducible observations.
        *
	* Reducible observations are attributes equivalent by closure to others observations.         
        * They are computed by `getReducibleElements` od `ClosureSystem`
        * applied on the reverse context in O(|O|^3|A|)
	* @return the set of reducibles removed attributes, with their equivalent attributes
	*/
	public TreeMap &lt;Comparable, TreeSet&lt;Comparable&gt;&gt; observationsReduction () {
            // compute the reducible elements of the reverse context            
<span class="nc" id="L651">            this.reverse();</span>
<span class="nc" id="L652">            TreeMap Red = this.getReducibleElements();            </span>
<span class="nc" id="L653">            this.reverse();</span>
            // remove the reducible elements from the observations set
<span class="nc bnc" id="L655" title="All 2 branches missed.">            for (Object att : Red.keySet()) </span>
<span class="nc" id="L656">                this.removeFromObservations((Comparable)att);            </span>
<span class="nc" id="L657">            return Red;</span>
        }
	/** Removes from this component reducible attributes and observations.
	*
        * They are computed by `attributesReduction` then 
        * `observationsReduction` in O(|A|^3|O|+|O|^3|A|)
	*
	*
	* @return the set of reducibles removed attributes and observations with their equivalent elements
	*/	
	public TreeMap &lt;Comparable, TreeSet&lt;Comparable&gt;&gt; reduction () {
<span class="nc" id="L668">            TreeMap &lt;Comparable, TreeSet&lt;Comparable&gt;&gt; Red = this.attributesReduction();</span>
<span class="nc" id="L669">            Red.putAll(this.observationsReduction());</span>
<span class="nc" id="L670">            return Red;</span>
	}	
	/** Reverses this component by replacing attributes by observations and observations by 
	* attributes. Intent and extent are exchanged in the same way.
	*/
	public void reverse () {
<span class="nc" id="L676">		TreeSet&lt;Comparable&gt; tmp = this.attributes;</span>
<span class="nc" id="L677">		this.attributes = this.observations;</span>
<span class="nc" id="L678">		this.observations = tmp;</span>
<span class="nc" id="L679">		TreeMap&lt;Comparable,TreeSet&lt;Comparable&gt;&gt; sauv = this.intent;</span>
<span class="nc" id="L680">		this.intent = this.extent;</span>
<span class="nc" id="L681">		this.extent = sauv;			</span>
<span class="nc" id="L682">	}</span>

        //cguerin - 2013-04-20 - return a new reversed Context
        public Context getReverseContext(){
<span class="nc" id="L686">            Context context = new Context(this);</span>
<span class="nc" id="L687">            TreeSet&lt;Comparable&gt; tmp = context.attributes;</span>
<span class="nc" id="L688">            context.attributes = context.observations;</span>
<span class="nc" id="L689">            context.observations = tmp;</span>
<span class="nc" id="L690">            TreeMap&lt;Comparable,TreeSet&lt;Comparable&gt;&gt; sauv = context.intent;</span>
<span class="nc" id="L691">            context.intent = context.extent;</span>
<span class="nc" id="L692">            context.extent = sauv;</span>
<span class="nc" id="L693">            return context;</span>
        }
    /* --------------- IMPLEMENTATION OF CLOSURE SYSTEM ABSTRACT METHODS ------------ */
	/* --------------- AND CONCEPT LATTICE GENERATION------------ */



	/** Returns the set of attributes as elements set used by the lattice generator abstract class
	* to generate closed set lattice on attributes. The closed set lattice on abservations can
	* be otained using the reverse method of this class.
	*/
	public TreeSet&lt;Comparable&gt; getSet() {
<span class="fc" id="L705">		return this.attributes;</span>
	}
	/**  Builds the closure of a set X of attributes.
	*
	* The closure corresponds to the maximal set of attributes having the
	* same intent as the specified one.
	* This treatment is performed in O(|A||O|)
	* @param X a TreeSet of indexed elements
	* @return  the closure of X for this component
	*/
	public TreeSet&lt;Comparable&gt; closure (TreeSet&lt;Comparable&gt; X) {
<span class="fc" id="L716">		return this.getIntent(this.getExtent(X));</span>
	}        
	/** Returns the set of union of observations that are intent with one of attributes of the specified set */
  	public TreeSet&lt;Comparable&gt; getExtentUnion (TreeSet&lt;Comparable&gt; X) {
<span class="nc" id="L720">		TreeSet&lt;Comparable&gt; ext = new TreeSet&lt;Comparable&gt;();</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">		for (Comparable att : X)</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">			for (Comparable obs : this.getExtent(att))</span>
<span class="nc bnc" id="L723" title="All 4 branches missed.">				if (this.containAsExtent(att,obs) &amp;&amp; !ext.contains(obs))</span>
<span class="nc" id="L724">					ext.add(obs);</span>
<span class="nc" id="L725">		return ext; }</span>

	/**  Builds the inverse of the closure operator of a set X of observations.
	*
	* The inverse closure corresponds to the maximal set of observations having the
	* same intent as the specified one.
	* This treatment is performed in O(|A||O|)
	* @param X a TreeSet of indexed elements
	* @return  the closure of X for this component
	*/
	public ComparableSet inverseClosure (ComparableSet X) {
<span class="nc" id="L736">		return new ComparableSet (this.getExtent(this.getIntent((TreeSet)X)));</span>
	}

    /** Returns the concept lattice of this component.
    *
    * A true value of the boolean `diagram` indicates that the
     * Hasse diagramm of the lattice is computed (i.e. it is transitively reduced),
     * whereas a false value indicates that the lattice is transitively closed
     *
     * The closed set lattice is first generated using
     * `ConceptLattice closedSetLattice (boolean  diagram)`
     * Then, nodes of the lattice are completed as concepts.
     *
     * @param diagram a boolean indicating if the Hasse diagramm of the lattice is computed or not.
	 **/
	public ConceptLattice conceptLattice (boolean  diagram) {
<span class="fc" id="L752">		ConceptLattice CSL = this.closedSetLattice(diagram);        </span>
<span class="fc" id="L753">		TreeMap&lt;Concept,Concept&gt; Nodes = new TreeMap&lt;Concept,Concept&gt;();</span>
<span class="fc bfc" id="L754" title="All 2 branches covered.">		for (Node n : CSL.getNodes()) {</span>
<span class="fc" id="L755">			 Concept cl = (Concept)n;</span>
<span class="fc" id="L756">             cl.putSetB(new ComparableSet(this.getExtent(cl.getSetA())));</span>
<span class="fc" id="L757">        }</span>
<span class="fc" id="L758">		return CSL;</span>
	}

}// end of Context		
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312101107</span></div></body></html>