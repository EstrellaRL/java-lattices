<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ImplicationalSystem.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Java Lattices</a> &gt; <a href="index.source.html" class="el_package">lattice</a> &gt; <span class="el_source">ImplicationalSystem.java</span></div><h1>ImplicationalSystem.java</h1><pre class="source lang-java linenums">package lattice;

/*
 * ImplicationalSystem.java
 *
 * Copyright: 2013 University of La Rochelle, France
 *
 * License: http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html CeCILL-B license
 *
 * This file is part of lattice, free package. You can redistribute it and/or modify
 * it under the terms of CeCILL-B license.
 *
 * @author Karell Bertet
 * @version 2013
 */

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Collection;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.TreeSet;
import dgraph.DGraph;
import dgraph.Edge;
import dgraph.Node;

/**
 * This class gives a representation for an implicational system (ImplicationalSystem), a set of rules.
 *
 * An ImplicationalSystem is composed of a treeset of comparable elements, and a treeset of rules
 * defined by class {@link Rule}.
 *
 * This class provides methods implementing classical transformation of an implicational system :
 * make proper, make minimum, make right maximal, make left minimal, make unary,
 * make canonical basis, make canonical direct basis and reduction.
 *
 * An implicational system owns properties of a closure system, and thus extends the abstract class
 * {@link ClosureSystem} and implements methods {@link #getSet} and {@link #closure}.
 *
 * Therefore, the closed set lattice of an ImplicationalSystem can be generated by invoking method {@link #closedSetLattice} of a closure system.
 *
 * An implicational system can be instancied from and save to a text file in the following format:
 * - a list of elements separated by a space in the first line ;
 * - then, each rule on a line, written like [premise] -&gt; [conclusion]
 *   where elements are separated by a space.
 *
 * ~~~
 * a b c d e
 * a b -&gt; c d
 * c d -&gt; e
 * ~~~
 *
 * ![ImplicationalSystem](ImplicationalSystem.png)
 *
 * @uml ImplicationalSystem.png
 * !include src/lattice/ImplicationalSystem.iuml
 * !include src/lattice/ClosureSystem.iuml
 *
 * hide members
 * show ImplicationalSystem members
 * class ImplicationalSystem #LightCyan
 * title ImplicationalSystem UML graph
 *
 * @todo  Standardize &quot;count&quot; method names
 */
public class ImplicationalSystem extends ClosureSystem {
    /*
     * Register txt writer
     */
    static {
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">        if (ImplicationalSystemWriterFactory.get(&quot;txt&quot;) == null) {</span>
<span class="fc" id="L75">            ImplicationalSystemWriterText.register();</span>
        }
<span class="fc" id="L77">    }</span>
    /*--------------- FIELDS -----------------*/

    /**
     * For the implicational rules of this component.
     */
    private TreeSet&lt;Rule&gt; sigma;

    /**
     * For the elements space of this component.
     */
    private TreeSet&lt;Comparable&gt; set;

    /* --------------- CONSTRUCTORS -----------*/

    /**
     * Constructs a new empty component.
     */
<span class="fc" id="L95">    public ImplicationalSystem() {</span>
<span class="fc" id="L96">        this.sigma = new TreeSet&lt;Rule&gt;();</span>
<span class="fc" id="L97">        this.set = new TreeSet&lt;Comparable&gt;();</span>
<span class="fc" id="L98">    }</span>

    /**
     * Constructs this component from the specified set of rules `sigma`.
     *
     * @param   sigma  the set of rules.
     */
<span class="fc" id="L105">    public ImplicationalSystem(Collection&lt;Rule&gt; sigma) {</span>
<span class="fc" id="L106">        this.sigma = new TreeSet&lt;Rule&gt;(sigma);</span>
<span class="fc" id="L107">        this.set = new TreeSet&lt;Comparable&gt;();</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">        for (Rule r : this.sigma) {</span>
<span class="fc" id="L109">            set.addAll(r.getPremise());</span>
<span class="fc" id="L110">            set.addAll(r.getConclusion());</span>
<span class="fc" id="L111">        }</span>
<span class="fc" id="L112">    }</span>

    /**
     * Constructs this component as a copy of the specified IS `s`.
     *
     * Only structures (conataining reference of indexed elements) are copied.
     *
     * @param   s  the implicational system to be copied
     */
<span class="fc" id="L121">    public ImplicationalSystem(ImplicationalSystem s) {</span>
<span class="fc" id="L122">        this.sigma = new TreeSet&lt;Rule&gt;(s.getRules());</span>
<span class="fc" id="L123">        this.set = new TreeSet&lt;Comparable&gt;(s.getSet());</span>
<span class="fc" id="L124">    }</span>

    /**
     * Constructs this component from the specified file.
     *
     * The file have to respect a certain format:
     *
     * An implicational system can be instancied from and save to a text file in the following format:
     * - A list of elements separated by a space in the first line ;
     * - then, each rule on a line, written like [premise] -&gt; [conclusion]
     *   where elements are separated by a space.
     *
     * ~~~
     * a b c d e
     * a b -&gt; c d
     * c d -&gt; e
     * ~~~
     *
     * Each element must be declared on the first line, otherwise, it is not added in the rule
     * Each rule must have a non empty concusion, otherwise, it is not added in the component
     *
     * @param   filename  the name of the file
     *
     * @throws  IOException  When an IOException occurs
     */
<span class="fc" id="L149">    public ImplicationalSystem(String filename) throws IOException {</span>
<span class="fc" id="L150">        this.sigma = new TreeSet&lt;Rule&gt;();</span>
<span class="fc" id="L151">        this.set = new TreeSet&lt;Comparable&gt;();</span>
<span class="fc" id="L152">        BufferedReader file = new BufferedReader(new FileReader(filename));</span>
        // first line : All elements of S separated by a space
        // a StringTokenizer is used to divide the line into different token,
        // considering spaces as separator.
<span class="fc" id="L156">        StringTokenizer st =  new StringTokenizer(file.readLine());</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">        while (st.hasMoreTokens()) {</span>
<span class="fc" id="L158">            String n = new String(st.nextToken());</span>
<span class="fc" id="L159">            this.addElement(n);</span>
<span class="fc" id="L160">        }</span>
        // next lines : [elements of the premise separated by a space] -&gt; [elements of the conclusion separated by a space]
        // a StringTokenizer is used to divide each rule.
<span class="fc" id="L163">        String line = file.readLine();</span>
<span class="pc bpc" id="L164" title="1 of 4 branches missed.">        while (!(line == null) &amp;&amp; !line.isEmpty()) {</span>
<span class="fc" id="L165">            st = new StringTokenizer(line);</span>
<span class="fc" id="L166">            Rule r = new Rule();</span>
<span class="fc" id="L167">            boolean prem = true;</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">            while (st.hasMoreTokens()) {</span>
<span class="fc" id="L169">                String word = st.nextToken();</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">                if (word.equals(&quot;-&gt;&quot;)) {</span>
<span class="fc" id="L171">                    prem = false;</span>
                } else {
<span class="fc" id="L173">                    String x = null;</span>
                    // search of x in S
<span class="fc bfc" id="L175" title="All 2 branches covered.">                    for (Comparable e : this.set) {</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">                        if (((String) e).equals(word)) {</span>
<span class="fc" id="L177">                            x = (String) e;</span>
                        }
<span class="fc" id="L179">                    }</span>
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">                    if (x != null) {</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">                        if (prem) {</span>
<span class="fc" id="L182">                            r.addToPremise(x);</span>
                        } else {
<span class="fc" id="L184">                        r.addToConclusion(x);</span>
                        }
                    }
                }
<span class="fc" id="L188">            }</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">            if (!r.getConclusion().isEmpty()) {</span>
<span class="fc" id="L190">                this.addRule(r);</span>
            }
<span class="fc" id="L192">            line = file.readLine();</span>
<span class="fc" id="L193">        }</span>
<span class="fc" id="L194">        file.close();</span>
<span class="fc" id="L195">    }</span>

    /**
     * Generates a random ImplicationalSystem with a specified number of nodes and rules.
     *
     * @param   nbS  the number of nodes of the generated ImplicationalSystem
     * @param   nbR  the number of rules of the generated ImplicationalSystem
     *
     * @return  a random implicational system with a specified number of nodes and rules.
     */
    public static ImplicationalSystem random(int nbS, int nbR) {
<span class="fc" id="L206">        ImplicationalSystem sigma = new ImplicationalSystem();</span>
        // addition of elements
<span class="fc bfc" id="L208" title="All 2 branches covered.">        for (int i = 0; i &lt; nbS; i++) {</span>
<span class="fc" id="L209">            sigma.addElement(new Integer(i));</span>
        }
        // addition of rules
        //for (int i = 0; i &lt; nbR; i++) { One could get twice the same rule ...
<span class="fc bfc" id="L213" title="All 2 branches covered.">        while (sigma.getRules().size() &lt; nbR) {</span>
<span class="fc" id="L214">            ComparableSet conclusion = new ComparableSet();</span>
<span class="fc" id="L215">            int choice = (int) Math.rint(nbS * Math.random());</span>
<span class="fc" id="L216">            int j = 1;</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">            for (Comparable c : sigma.getSet()) {</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">                if (j == choice) {</span>
<span class="fc" id="L219">                    conclusion.add(c);</span>
                }
<span class="fc" id="L221">                j++;</span>
<span class="fc" id="L222">            }</span>
<span class="fc" id="L223">            ComparableSet premisse = new ComparableSet();</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">            for (Comparable c : sigma.getSet()) {</span>
<span class="fc" id="L225">                choice = (int) Math.rint(nbS * Math.random());</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">                if (choice &lt; nbS / 5) {</span>
<span class="fc" id="L227">                    premisse.add(c);</span>
                }
<span class="fc" id="L229">            }</span>
            //if (!premisse.isEmpty()) {
<span class="fc" id="L231">                sigma.addRule(new Rule(premisse, conclusion));</span>
            //}
<span class="fc" id="L233">        }</span>
<span class="fc" id="L234">        return sigma;</span>
    }

    /* ------------- ACCESSORS METHODS ------------------ */

    /**
     * Returns the set of rules.
     *
     * @return  the set of rules of this component.
     */
    public TreeSet&lt;Rule&gt; getRules() {
<span class="fc" id="L245">        return this.sigma;</span>
    }

    /**
     * Returns the set of indexed elements.
     *
     * @return  the elements space of this component.
     */
    public TreeSet&lt;Comparable&gt; getSet() {
<span class="fc" id="L254">        return this.set;</span>
    }

    /**
     * Returns the number of elements in the set S of this component.
     *
     * @return  the number of elements in the elements space of this component.
     */
    public int nbElements() {
<span class="fc" id="L263">        return this.set.size();</span>
    }

    /**
     * Returns the number of rules of this component.
     *
     * @return  the number of rules of this component.
     */
    public int nbRules() {
<span class="fc" id="L272">        return this.sigma.size();</span>
    }

    /* ------------- MODIFICATION METHODS ------------------ */

    /**
     * Adds the specified element to the set `S` of this component.
     *
     * @param   e  the comparable to be added
     *
     * @return  true if the element has been added to `S`
     */
    public boolean addElement(Comparable e) {
<span class="fc" id="L285">        return set.add(e);</span>
    }

    /**
     * Adds the specified element to the set `S` of this component.
     *
     * @param   x  the treeset of comparable to be added
     *
     * @return  true if the element has been added to `S`
     */
    public boolean addAllElements(TreeSet&lt;Comparable&gt; x) {
<span class="fc" id="L296">        boolean all = true;</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">        for (Comparable e : x) {</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">            if (!set.add(e)) {</span>
<span class="nc" id="L299">                all = false;</span>
            }
<span class="fc" id="L301">        }</span>
<span class="fc" id="L302">        return all;</span>
    }

    /**
     * Delete the specified element from the set `S` of this component and from all the rule containing it.
     *
     * @param   e  the comparable to be added
     *
     * @return true if the element has been added to `S`
     */
    public boolean deleteElement(Comparable e) {
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        if (set.contains(e)) {</span>
<span class="fc" id="L314">            set.remove(e);</span>
<span class="fc" id="L315">            ImplicationalSystem sauv = new ImplicationalSystem(this);</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">            for (Rule r: sauv.sigma) {</span>
<span class="fc" id="L317">                Rule newR = new Rule(r.getPremise(), r.getConclusion());</span>
<span class="fc" id="L318">                newR.removeFromPremise(e);</span>
<span class="fc" id="L319">                newR.removeFromConclusion(e);</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">                if (!r.equals(newR)) {</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">                    if (newR.getConclusion().size() != 0) {</span>
<span class="nc" id="L322">                        this.replaceRule(r, newR);</span>
                    } else {
<span class="fc" id="L324">                        this.removeRule(r);</span>
                    }
                }
<span class="fc" id="L327">            }</span>
<span class="fc" id="L328">            return true;</span>
        }
<span class="nc" id="L330">        return false;</span>
    }

    /**
     * Checks if the set S of this component contains the elements of the specified rule.
     *
     * @param   r  the rule to be checked
     *
     * @return  true if `S` contains all the elements of the rule
     */
    public boolean checkRuleElements(Rule r) {
<span class="fc bfc" id="L341" title="All 2 branches covered.">        for (Object e : r.getPremise()) {</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">            if (!set.contains(e)) {</span>
<span class="nc" id="L343">                return false;</span>
            }
<span class="fc" id="L345">        }</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">        for (Object e : r.getConclusion()) {</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">            if (!set.contains(e)) {</span>
<span class="nc" id="L348">                return false;</span>
            }
<span class="fc" id="L350">        }</span>
<span class="fc" id="L351">        return true;</span>
    }

    /**
     * Checks if this component already contains the specified rule.
     *
     * Rules are compared according to their premise and conclusion
     *
     * @param   r  the rule to be tested
     *
     * @return true if `sigma` contains the rule
     */
    public boolean containsRule(Rule r) {
<span class="fc" id="L364">        return this.sigma.contains(r);</span>
    }

    /**
     * Adds the specified rule to this component.
     *
     * @param   r  the rule to be added
     *
     * @return  true the rule has been added to if `sigma`
     */
    public boolean addRule(Rule r) {
<span class="pc bpc" id="L375" title="1 of 4 branches missed.">        if (!this.containsRule(r) &amp;&amp; this.checkRuleElements(r)) {</span>
<span class="fc" id="L376">            return this.sigma.add(r);</span>
        }
<span class="fc" id="L378">        return false;</span>
    }

    /**
     * Removes the specified rule from the set of rules of this component.
     *
     * @param   r  the rule to be removed
     *
     * @return  true if the rule has been removed
     */
    public boolean removeRule(Rule r) {
<span class="fc" id="L389">        return this.sigma.remove(r);</span>
    }

    /**
     * Replaces the first specified rule by the second one.
     *
     * @param   r1  the rule to be replaced by `r2`
     * @param   r2  the replacing rule
     *
     * @return  true the rule has been replaced
     */
    public boolean replaceRule(Rule r1, Rule r2) {
<span class="pc bpc" id="L401" title="2 of 4 branches missed.">        return (this.removeRule(r1) &amp;&amp; this.addRule(r2));</span>
    }

    /*-----------  SAVING METHODS -------------------- */

    /**
     * Returns a string representation of this component.
     *
     * The following format is used:
     *
     * An implicational system can be instancied from and save to a text file in the following format:
     * - A list of elements separated by a space in the first line ;
     * - then, each rule on a line, written like [premise] -&gt; [conclusion]
     *   where elements are separated by a space.
     *
     * ~~~
     * a b c d e
     * a b -&gt; c d
     * c d -&gt; e
     * ~~~
     *
     * @return  a string representation of this component.
     */
    public String toString() {
<span class="fc" id="L425">        StringBuffer s = new StringBuffer();</span>
        // first line : All elements of S separated by a space
        // a StringTokenizer is used to delete spaces in the
        // string description of each element of S
<span class="fc bfc" id="L429" title="All 2 branches covered.">        for (Comparable e : this.set) {</span>
<span class="fc" id="L430">            StringTokenizer st = new StringTokenizer(e.toString());</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">            while (st.hasMoreTokens()) {</span>
<span class="fc" id="L432">                s.append(st.nextToken());</span>
            }
<span class="fc" id="L434">            s.append(&quot; &quot;);</span>
<span class="fc" id="L435">        }</span>
<span class="fc" id="L436">        s.append(&quot;\n&quot;);</span>
        // next lines : a rule on each line, described by:
        // [elements of the premise separated by a space] -&gt; [elements of the conclusion separated by a space]
<span class="fc bfc" id="L439" title="All 2 branches covered.">        for (Rule r : this.sigma) {</span>
<span class="fc" id="L440">            s.append(r.toString()).append(&quot;\n&quot;);</span>
<span class="fc" id="L441">        }</span>
<span class="fc" id="L442">        return s.toString();</span>
    }

    /**
     * Save the description of this component in a file whose name is specified.
     *
     * @param   filename  the name of the file
     *
     * @throws  IOException  When an IOException occurs
     */
    public void save(final String filename) throws IOException {
<span class="fc" id="L453">        String extension = &quot;&quot;;</span>
<span class="fc" id="L454">        int index = filename.lastIndexOf('.');</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">        if (index &gt; 0) {</span>
<span class="fc" id="L456">            extension = filename.substring(index + 1);</span>
        }
<span class="fc" id="L458">        BufferedWriter file = new BufferedWriter(new FileWriter(filename));</span>
<span class="fc" id="L459">        ImplicationalSystemWriterFactory.get(extension).write(this, file);</span>
<span class="fc" id="L460">        file.close();</span>
<span class="fc" id="L461">    }</span>

    /*-----------  PROPERTIES TEST METHODS -------------------- */

    /**
     * Returns true if this component is a proper ImplicationalSystem.
     *
     * This test is perfomed in O(|Sigma||S|) by testing conclusion of each rule
     *
     * @return  true if and only if this component is a proper implicational system.
     */
    public boolean isProper() {
<span class="fc bfc" id="L473" title="All 2 branches covered.">        for (Rule r : this.sigma) {</span>
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">            if (r.getPremise().contains(r.getConclusion())) {</span>
<span class="nc" id="L475">                return false;</span>
            }
<span class="fc" id="L477">        }</span>
<span class="fc" id="L478">        return true;</span>
    }

    /**
     * Returns true if this component is an unary ImplicationalSystem.
     *
     * This test is perfomed in O(|Sigma||S|) by testing conclusion of each rule
     *
     * @return  true if this component is an unary ImplicationalSystem.
     */
    public boolean isUnary() {
<span class="fc bfc" id="L489" title="All 2 branches covered.">        for (Rule r : this.sigma) {</span>
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">            if (r.getConclusion().size() &gt; 1) {</span>
<span class="nc" id="L491">                return false;</span>
            }
<span class="fc" id="L493">        }</span>
<span class="fc" id="L494">        return true;</span>
    }

    /**
     * Returns true if this component is a compact ImplicationalSystem.
     *
     * This test is perfomed in O(|Sigma|^2|S|) by testing premises of each pair of rules
     *
     * @return  true if this component is a compact ImplicationalSystem.
     */
    public boolean isCompact() {
<span class="fc bfc" id="L505" title="All 2 branches covered.">        for (Rule r1 : this.sigma) {</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">            for (Rule r2: this.sigma) {</span>
<span class="pc bpc" id="L507" title="1 of 4 branches missed.">                if (!r1.equals(r2) &amp;&amp; (r1.getPremise().equals(r2.getPremise()))) {</span>
<span class="nc" id="L508">                    return false;</span>
                }
<span class="fc" id="L510">            }</span>
<span class="fc" id="L511">        }</span>
<span class="fc" id="L512">        return true;</span>
    }

    /**
     * Returns true if conclusion of rules of this component are closed.
     *
     * This test is perfomed in O(|Sigma||S|) by testing conclusion of each rule
     *
     * @return  true if conclusion of rules of this component are closed.
     */
    public boolean isRightMaximal() {
<span class="fc bfc" id="L523" title="All 2 branches covered.">        for (Rule r : this.sigma) {</span>
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">            if (!r.getConclusion().containsAll(this.closure(r.getConclusion()))) {</span>
<span class="nc" id="L525">                return false;</span>
            }
<span class="fc" id="L527">        }</span>
<span class="fc" id="L528">        return true;</span>
    }

    /**
     * Returns true if this component is left minimal.
     *
     * This test is perfomed in O(|Sigma|^2|S|) by testing conclusions of each pair of rules
     *
     * @return  true if this component is left minimal.
     */
    public boolean isLeftMinimal() {
<span class="fc bfc" id="L539" title="All 2 branches covered.">        for (Rule r1 : this.sigma) {</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">            for (Rule r2 : this.sigma) {</span>
<span class="pc bpc" id="L541" title="1 of 6 branches missed.">                if (!r1.equals(r2) &amp;&amp; r1.getPremise().containsAll(r2.getPremise()) &amp;&amp; r1.getConclusion().equals(r2.getConclusion())) {</span>
<span class="nc" id="L542">                    return false;</span>
                }
<span class="fc" id="L544">            }</span>
<span class="fc" id="L545">        }</span>
<span class="fc" id="L546">        return true;</span>
    }

    /**
     * Returns true if this component is direct.
     *
     * This test is perfomed in O(|Sigma|^2|S|) by testing if closure of
     * the premisse of each conclusion can be obtained by only one iteration
     * on the set of rules.
     *
     * @return  true if this component is direct.
     */
    public boolean isDirect() {
<span class="fc bfc" id="L559" title="All 2 branches covered.">        for (Rule r1 : this.sigma) {</span>
<span class="fc" id="L560">            TreeSet&lt;Comparable&gt; onePass = new TreeSet(r1.getPremise());</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">            for (Rule r2 : this.sigma) {</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">                if (r1.getPremise().containsAll(r2.getPremise())) {</span>
<span class="fc" id="L563">                    onePass.addAll(r2.getConclusion());</span>
                }
<span class="fc" id="L565">            }</span>
<span class="pc bpc" id="L566" title="1 of 2 branches missed.">            if (!onePass.equals(this.closure(r1.getPremise()))) {</span>
<span class="nc" id="L567">                return false;</span>
            }
<span class="fc" id="L569">        }</span>
<span class="fc" id="L570">        return true;</span>
    }

    /**
     * Returns true if this component is minimum.
     *
     * This test is perfomed in O(|Sigma|^2|S|) by testing if closure of
     * the premisse of each conclusion can be obtained by only one iteration
     * on the set of rules.
     *
     * @return  true if this component is minimum.
     */
    public boolean isMinimum() {
<span class="fc" id="L583">        ImplicationalSystem tmp = new ImplicationalSystem(this);</span>
<span class="fc" id="L584">        tmp.makeRightMaximal();</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">        for (Rule r : sigma) {</span>
<span class="fc" id="L586">            ImplicationalSystem epsylon = new ImplicationalSystem(tmp);</span>
<span class="fc" id="L587">            epsylon.removeRule(r);</span>
<span class="fc" id="L588">            TreeSet&lt;Comparable&gt; clThis = this.closure(r.getPremise());</span>
<span class="fc" id="L589">            TreeSet&lt;Comparable&gt; clEpsilon = epsylon.closure(r.getPremise());</span>
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">            if (clThis.equals(clEpsilon)) {</span>
<span class="nc" id="L591">                return false;</span>
            }
<span class="fc" id="L593">        }</span>
<span class="fc" id="L594">        return true;</span>
    }

    /**
     * Returns true if this component is equal to its canonical direct basis.
     *
     * The canonical direct basis is computed before to be compare with this component.
     *
     * This test is performed in O(d|S|), where d corresponds to the number of rules
     * that have to be added by the direct treatment. This number is exponential in the worst case.
     *
     * @return  true if this component is equal to its canonical direct basis.
     */
    public boolean isCanonicalDirectBasis() {
<span class="fc" id="L608">        ImplicationalSystem cdb = new ImplicationalSystem(this);</span>
<span class="fc" id="L609">        cdb.makeCanonicalDirectBasis();</span>
<span class="pc bpc" id="L610" title="2 of 4 branches missed.">        return (this.isIncludedIn(cdb) &amp;&amp; cdb.isIncludedIn(this));</span>
    }

    /**
     * Returns true if this component is equal to its canonical basis.
     *
     * The canonical basis is computed before to be compare with this component.
     *
     * This treatment is performed in (|Sigma||S|cl) where O(cl) is the
     * computation of a closure.
     *
     * @return  true if this component is equal to its canonical basis.
     */
    public boolean isCanonicalBasis() {
<span class="fc" id="L624">        ImplicationalSystem cb = new ImplicationalSystem(this);</span>
<span class="fc" id="L625">        cb.makeCanonicalBasis();</span>
<span class="pc bpc" id="L626" title="2 of 4 branches missed.">        return (this.isIncludedIn(cb) &amp;&amp; cb.isIncludedIn(this));</span>
    }

    /**
     * Compares by inclusion of the proper and unary form of this component with the specified one.
     *
     * @param   is  another ImplicationalSystem
     *
     * @return  true if really include in this componenet.
     */
    public boolean isIncludedIn(ImplicationalSystem is) {
<span class="fc" id="L637">        ImplicationalSystem tmp = new ImplicationalSystem(this);</span>
<span class="fc" id="L638">        tmp.makeProper();</span>
<span class="fc" id="L639">        tmp.makeUnary();</span>
<span class="fc" id="L640">        is.makeProper();</span>
<span class="fc" id="L641">        is.makeUnary();</span>
<span class="fc bfc" id="L642" title="All 2 branches covered.">        for (Rule r : tmp.sigma) {</span>
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">            if (!is.containsRule(r)) {</span>
<span class="nc" id="L644">                return false;</span>
            }
<span class="fc" id="L646">        }</span>
<span class="fc" id="L647">        return true;</span>
    }

    /*-----------  PROPERTIES MODIFICATION METHODS -------------------- */

    /**
     * Makes this component a proper ImplicationalSystem.
     *
     * Elements that are at once in the conclusion and in the premise are deleted from the conclusion.
     * When the obtained conclusion is an empty set, the rule is deleted from this component
     *
     * This treatment is performed in O(|Sigma||S|).
     *
     * @return  the difference between the number of rules of this component before and after this treatment
     */
    public int makeProper() {
<span class="fc" id="L663">        ImplicationalSystem sauv = new ImplicationalSystem(this);</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">        for (Rule r : sauv.sigma) {</span>
            // deletes elements of conclusion which are in the premise
<span class="fc" id="L666">            Rule newR = new Rule(r.getPremise(), r.getConclusion());</span>
<span class="fc bfc" id="L667" title="All 2 branches covered.">            for (Object e : r.getConclusion()) {</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">                if (newR.getPremise().contains(e)) {</span>
<span class="fc" id="L669">                    newR.removeFromConclusion(e);</span>
                }
<span class="fc" id="L671">            }</span>
            // replace the rule by the new rule is it has been modified
<span class="fc bfc" id="L673" title="All 2 branches covered.">            if (!r.equals(newR)) {</span>
<span class="fc" id="L674">                this.replaceRule(r, newR);</span>
            }
            // delete rule with an empty conclusion
<span class="fc bfc" id="L677" title="All 2 branches covered.">            if (newR.getConclusion().isEmpty()) {</span>
<span class="fc" id="L678">                this.removeRule(newR);</span>
            }
<span class="fc" id="L680">        }</span>
<span class="fc" id="L681">        return sauv.nbRules() - this.nbRules();</span>
    }

    /**
     * Makes this component an unary ImplicationalSystem.
     *
     * This treatment is performed in O(|Sigma||S|)
     *
     * A rule with a non singleton as conclusion is replaced with a sets of rule, one rule for each
     * element of the conclusion.
     *
     * This treatment is performed in O(|Sigma||S|).
     *
     * @return  the difference between the number of rules of this component before and after this treatment
     */
    public int makeUnary() {
<span class="fc" id="L697">        ImplicationalSystem sauv = new ImplicationalSystem(this);</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">        for (Rule r : sauv.sigma) {</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">            if (r.getConclusion().size() &gt; 1) {</span>
<span class="fc" id="L700">                this.removeRule(r);</span>
<span class="fc" id="L701">                TreeSet&lt;Comparable&gt; conclusion = r.getConclusion();</span>
<span class="fc" id="L702">                TreeSet&lt;Comparable&gt; premise = r.getPremise();</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">                for (Comparable e : conclusion) {</span>
<span class="fc" id="L704">                    TreeSet&lt;Comparable&gt; newC = new TreeSet();</span>
<span class="fc" id="L705">                    newC.add(e);</span>
<span class="fc" id="L706">                    Rule nr = new Rule(premise, newC);</span>
<span class="fc" id="L707">                    this.addRule(nr);</span>
<span class="fc" id="L708">                }</span>
            }
<span class="fc" id="L710">        }</span>
<span class="fc" id="L711">        return sauv.nbRules() - this.nbRules();</span>
    }

    /**
     * Replaces rules of same premise by only one rule.
     *
     * This treatment is performed in O(|sigma|^2|S|)
     *
     * @return  the difference between the number of rules of this component before and after this treatment
     */
    public int makeCompact() {
<span class="fc" id="L722">        ImplicationalSystem sauv = new ImplicationalSystem(this);</span>
<span class="fc bfc" id="L723" title="All 2 branches covered.">        for (Rule r1 : sauv.sigma) {</span>
<span class="fc bfc" id="L724" title="All 2 branches covered.">            if (this.containsRule(r1)) {</span>
<span class="fc" id="L725">                ComparableSet newConc = new ComparableSet();</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">                for (Rule r2 : sauv.sigma) {</span>
<span class="fc bfc" id="L727" title="All 6 branches covered.">                    if (this.containsRule(r2) &amp;&amp; !r1.equals(r2) &amp;&amp; (r1.getPremise().equals(r2.getPremise()))) {</span>
<span class="fc" id="L728">                        newConc.addAll(r2.getConclusion());</span>
<span class="fc" id="L729">                        boolean res = this.sigma.remove(r2);</span>
                    }
<span class="fc" id="L731">                }</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">                if (newConc.size() &gt; 0) {</span>
<span class="fc" id="L733">                    newConc.addAll(r1.getConclusion());</span>
<span class="fc" id="L734">                    Rule newR = new Rule(r1.getPremise(), newConc);</span>
<span class="pc bpc" id="L735" title="1 of 2 branches missed.">                    if (!r1.equals(newR)) {</span>
<span class="fc" id="L736">                        this.replaceRule(r1, newR);</span>
                    }
                }
            }
<span class="fc" id="L740">        }</span>
<span class="fc" id="L741">        return sauv.nbRules() - this.nbRules();</span>
    }

    /**
     * Replaces conclusion of each rule with their closure without the premise.
     *
     * This treatment is performed in O(|sigma||S|cl), where O(cl) is the
     * computation of a closure.
     *
     * @return  the difference between the number of rules of this component before and after this treatment
     */
    public int makeRightMaximal() {
<span class="fc" id="L753">        int s = this.nbRules();</span>
<span class="fc" id="L754">        this.makeCompact();</span>
<span class="fc" id="L755">        ImplicationalSystem sauv = new ImplicationalSystem(this);</span>
<span class="fc bfc" id="L756" title="All 2 branches covered.">        for (Rule r : sauv.sigma) {</span>
<span class="fc" id="L757">            Rule newR = new Rule(r.getPremise(), this.closure(r.getPremise()));</span>
<span class="fc bfc" id="L758" title="All 2 branches covered.">            if (!r.equals(newR)) {</span>
<span class="fc" id="L759">                this.replaceRule(r, newR);</span>
            }
<span class="fc" id="L761">        }</span>
<span class="fc" id="L762">        return s - this.nbRules();</span>
    }

    /**
     * Makes this component a left minimal and compact ImplicationalSystem.
     *
     * The unary form of this componant is first computed: if two rules have the
     * same unary conclusion, the rule with the inclusion-maximal premise is deleted.
     *
     * Then, the left-minimal treatment is performed in O(|sigma|^2|S|))
     *
     * @return  the difference between the number of rules of this component before and after this treatment
     */
    public int makeLeftMinimal() {
<span class="fc" id="L776">        this.makeUnary();</span>
<span class="fc" id="L777">        ImplicationalSystem sauv = new ImplicationalSystem(this);</span>
<span class="fc bfc" id="L778" title="All 2 branches covered.">        for (Rule r1 : sauv.sigma) {</span>
<span class="fc bfc" id="L779" title="All 2 branches covered.">            for (Rule r2 : sauv.sigma) {</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">                if (!r1.equals(r2)) {</span>
<span class="fc bfc" id="L781" title="All 4 branches covered.">                    if ((r2.getPremise().containsAll(r1.getPremise())) &amp;&amp; (r1.getConclusion().equals(r2.getConclusion()))) {</span>
<span class="fc" id="L782">                        this.sigma.remove(r2);</span>
                    }
                }
<span class="fc" id="L785">            }</span>
<span class="fc" id="L786">        }</span>
<span class="fc" id="L787">        this.makeCompact();</span>
<span class="fc" id="L788">        return sauv.nbRules() - this.nbRules();</span>
    }

    /**
     * Makes this component a compact and direct ImplicationalSystem.
     *
     * The unary and proper form of this componant is first computed.
     * For two given rules r1 and r2, if the conclusion of r1 contains the premise of r1,
     * then a new rule is addes, with r1.premisse + r2.premisse - r1.conclusion as premise, and
     * r2.conclusion as conlusion. This treatment is performed in a recursive way until no new rule
     * is added.
     *
     * This treatment is performed in O(d|S|), where d  corresponds to the number of rules
     * that have to be added by the direct treatment, that can be exponential in the worst case.
     *
     * @return  the difference between the number of rules of this component before and after this treatment
     */
    public int makeDirect() {
<span class="fc" id="L806">        this.makeUnary();</span>
<span class="fc" id="L807">        this.makeProper();</span>
<span class="fc" id="L808">        int s = this.nbRules();</span>
<span class="fc" id="L809">        boolean ok = true;</span>
<span class="fc bfc" id="L810" title="All 2 branches covered.">        while (ok) {</span>
<span class="fc" id="L811">            ImplicationalSystem sauv = new ImplicationalSystem(this);</span>
<span class="fc bfc" id="L812" title="All 2 branches covered.">            for (Rule r1 : sauv.sigma) {</span>
<span class="fc bfc" id="L813" title="All 2 branches covered.">                for (Rule r2 : sauv.sigma) {</span>
<span class="fc bfc" id="L814" title="All 4 branches covered.">                    if (!r1.equals(r2) &amp;&amp; !r1.getPremise().containsAll(r2.getConclusion())) {</span>
<span class="fc" id="L815">                        ComparableSet  c = new ComparableSet(r2.getPremise());</span>
<span class="fc" id="L816">                        c.removeAll(r1.getConclusion());</span>
<span class="fc" id="L817">                        c.addAll(r1.getPremise());</span>
<span class="fc bfc" id="L818" title="All 2 branches covered.">                        if (!c.containsAll(r2.getPremise())) {</span>
<span class="fc" id="L819">                            Rule newR  = new Rule(c, r2.getConclusion());</span>
                            // new_r.addAllToPremise (r1.getPremise());
                            // new_r.addAllToPremise (r2.getPremise());
                            // new_r.removeAllFromPremise(r1.getConclusion());
                            // new_r.addAllToConclusion(r2.getConclusion() );
<span class="fc" id="L824">                            this.addRule(newR);</span>
                        }
                    }
<span class="fc" id="L827">                }</span>
<span class="fc" id="L828">            }</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">            if (this.nbRules() == sauv.nbRules()) {</span>
<span class="fc" id="L830">                ok = false;</span>
            }
<span class="fc" id="L832">        }</span>
<span class="fc" id="L833">        this.makeCompact();</span>
<span class="fc" id="L834">        return s - this.nbRules();</span>
    }

    /**
     * Makes this component a minimum and proper ImplicationalSystem.
     *
     * A rule is deleted when the closure of its premisse remains the same
     * even if this rule is suppressed.
     *
     * This treatment is performed in O(|sigma||S|cl) where O(cl) is the
     * computation of a closure.
     *
     * @return  the difference between the number of rules of this component before and after this treatment
     */
    public int makeMinimum() {
<span class="fc" id="L849">        this.makeRightMaximal();</span>
<span class="fc" id="L850">        ImplicationalSystem sauv = new ImplicationalSystem(this);</span>
<span class="fc bfc" id="L851" title="All 2 branches covered.">        for (Rule r : sauv.sigma) {</span>
<span class="fc" id="L852">            ImplicationalSystem epsylon = new ImplicationalSystem(this);</span>
<span class="fc" id="L853">            epsylon.removeRule(r);</span>
<span class="fc bfc" id="L854" title="All 2 branches covered.">            if (epsylon.closure(r.getPremise()).equals(this.closure(r.getPremise()))) {</span>
<span class="fc" id="L855">                this.removeRule(r);</span>
            }
<span class="fc" id="L857">        }</span>
<span class="fc" id="L858">        return sauv.nbRules() - this.nbRules();</span>
    }

    /**
     * Replace this component by its canonical direct basis.
     *
     * The proper, unary and left minimal form of this component is first computed,
     * before to apply the recursive directe treatment, then the left minimal treatment.
     *
     * This treatment is performed in O(d), where d corresponds to the number of rules
     * that have to be added by the direct treatment. This number is exponential in the worst case.
     *
     * @return  the difference between the number of rules of this component before and after this treatment
     */
    public int makeCanonicalDirectBasis() {
<span class="fc" id="L873">        int s = this.nbRules();</span>
<span class="fc" id="L874">        this.makeProper();</span>
<span class="fc" id="L875">        this.makeLeftMinimal();</span>
<span class="fc" id="L876">        this.makeDirect();</span>
<span class="fc" id="L877">        this.makeLeftMinimal();</span>
<span class="fc" id="L878">        this.makeCompact();</span>
<span class="fc" id="L879">        return s - this.nbRules();</span>
    }

    /**
     * Replace this component by the canonical basis.
     *
     * Conclusion of each rule is first replaced by its closure.
     * Then, premise of each rule r is replaced by its closure in ImplicationalSystem \ r.
     * This treatment is performed in (|Sigma||S|cl) where O(cl) is the
     * computation of a closure.
     *
     * @return  the difference between the number of rules of this component before and after this treatment
     */
    public int makeCanonicalBasis() {
<span class="fc" id="L893">        this.makeMinimum();</span>
<span class="fc" id="L894">        ImplicationalSystem sauv = new ImplicationalSystem(this);</span>
<span class="fc bfc" id="L895" title="All 2 branches covered.">        for (Rule r : sauv.sigma) {</span>
<span class="fc" id="L896">            ImplicationalSystem epsylon = new ImplicationalSystem(this);</span>
<span class="fc" id="L897">            epsylon.removeRule(r);</span>
<span class="fc" id="L898">            Rule tmp = new Rule(epsylon.closure(r.getPremise()), r.getConclusion());</span>
<span class="fc bfc" id="L899" title="All 2 branches covered.">            if (!r.equals(tmp)) {</span>
<span class="fc" id="L900">                this.replaceRule(r, tmp);</span>
            }
<span class="fc" id="L902">        }</span>
<span class="fc" id="L903">        this.makeProper();</span>
<span class="fc" id="L904">        return sauv.nbRules() - this.nbRules();</span>
    }

    /* --------------- METHODS BASED ON GRAPH ------------ */

    /**
     * Returns the representative graph of this component.
     *
     * Nodes of the graph are attributes of this components.
     * For each proper rule X+b-&gt;a, there is an {X}-valuated edge from a to b.
     * Notice that, for a rule b-&gt;a, the edge from a to b is valuated by emptyset.
     * and for the two rules X+b-&gt;a and Y+b-&gt;a, the edge from a to b is valuated by {X,Y}.
     *
     * @return  the representative graph of this component.
     */
    public DGraph representativeGraph() {
<span class="fc" id="L920">        ImplicationalSystem tmp = new ImplicationalSystem(this);</span>
<span class="fc" id="L921">        tmp.makeUnary();</span>
        // nodes of the graph are elements not belonging to X
<span class="fc" id="L923">        DGraph pred = new DGraph();</span>
<span class="fc" id="L924">        TreeMap&lt;Comparable, Node&gt; nodeCreated = new TreeMap&lt;Comparable, Node&gt;();</span>
<span class="fc bfc" id="L925" title="All 2 branches covered.">        for (Comparable x : tmp.getSet()) {</span>
<span class="fc" id="L926">            Node n = new Node(x);</span>
<span class="fc" id="L927">            pred.addNode(n);</span>
<span class="fc" id="L928">            nodeCreated.put(x, n);</span>
<span class="fc" id="L929">        }</span>
        // an edge is added from b to a when there exists a rule X+a -&gt; b or a -&gt; b
<span class="fc bfc" id="L931" title="All 2 branches covered.">        for (Rule r : tmp.getRules()) {</span>
<span class="fc bfc" id="L932" title="All 2 branches covered.">            for (Comparable a : r.getPremise()) {</span>
<span class="fc" id="L933">                ComparableSet diff = new ComparableSet(r.getPremise());</span>
<span class="fc" id="L934">                diff.remove(a);</span>
<span class="fc" id="L935">                Node from = nodeCreated.get(r.getConclusion().first());</span>
<span class="fc" id="L936">                Node to = nodeCreated.get(a);</span>
                Edge ed;
<span class="pc bpc" id="L938" title="1 of 2 branches missed.">                if (pred.containsEdge(from, to)) {</span>
<span class="nc" id="L939">                    ed = pred.getEdge(from, to);</span>
                } else {
<span class="fc" id="L941">                    ed = new Edge(from, to, new TreeSet&lt;ComparableSet&gt;());</span>
<span class="fc" id="L942">                    pred.addEdge(ed);</span>
                }
<span class="fc" id="L944">                ((TreeSet&lt;ComparableSet&gt;) ed.getContent()).add(diff);</span>
<span class="fc" id="L945">            }</span>
<span class="fc" id="L946">        }</span>
<span class="fc" id="L947">        return pred;</span>
    }

    /**
     * Returns the dependency graph of this component.
     *
     * Dependency graph of this component is the representative
     * graph of the canonical direct basis.
     * Therefore, the canonical direct basis has to be generated before
     * to compute its representativ graph, and
     * this treatment is performed in O(d), as for the canonical direct basis generation,
     * where d corresponds to the number of rules
     * that have to be added by the direct treatment. This number is exponential in the worst case.
     *
     * @return  the dependency graph of this component.
     */
    public DGraph dependencyGraph() {
<span class="fc" id="L964">        ImplicationalSystem bcd = new ImplicationalSystem(this);</span>
<span class="fc" id="L965">        bcd.makeCanonicalDirectBasis();</span>
<span class="fc" id="L966">        bcd.makeUnary();</span>
<span class="fc" id="L967">        return bcd.representativeGraph();</span>
    }

    /**
     * Removes from this component reducible elements.
     *
     * Reducible elements are elements equivalent by closure to others elements.
     * They are computed by `getReducibleElements` of `ClosureSystem`
     * in O(O(|Sigma||S|^2)
     *
     * @return  the set of reducibles removed elements, with their equivalent elements
     */
    public TreeMap&lt;Comparable, TreeSet&lt;Comparable&gt;&gt; reduction() {
        // compute the reducible elements
<span class="fc" id="L981">        TreeMap red = this.getReducibleElements();</span>
        // collect elements implied by nothing
<span class="fc" id="L983">        TreeSet&lt;Comparable&gt; truth = this.closure(new TreeSet&lt;Comparable&gt;());</span>
        // modify each rule
<span class="fc bfc" id="L985" title="All 2 branches covered.">        for (Object x : red.keySet()) {</span>
<span class="fc" id="L986">            TreeSet&lt;Rule&gt; rules = this.getRules();</span>
<span class="fc" id="L987">            rules = (TreeSet&lt;Rule&gt;) rules.clone();</span>
<span class="fc bfc" id="L988" title="All 2 branches covered.">            for (Rule r : rules) {</span>
<span class="fc" id="L989">                Rule r2 = new Rule();</span>
<span class="fc" id="L990">                boolean modif = false;</span>
                // replace the reducible element by its equivalent in the premise
<span class="fc" id="L992">                TreeSet premise = r.getPremise();</span>
<span class="fc" id="L993">                premise = (TreeSet) premise.clone();</span>
<span class="pc bpc" id="L994" title="1 of 2 branches missed.">                if (premise.contains(x)) {</span>
<span class="nc" id="L995">                    premise.remove(x);</span>
<span class="nc" id="L996">                    premise.addAll((TreeSet) red.get(x));</span>
<span class="nc" id="L997">                    r2.addAllToPremise(premise);</span>
<span class="nc" id="L998">                    modif = true;</span>
                } else {
<span class="fc" id="L1000">                    r2.addAllToPremise(premise);</span>
                }
                // replace the reducible element by its equivalent in the conclusion
<span class="fc" id="L1003">                TreeSet conclusion = r.getConclusion();</span>
<span class="fc" id="L1004">                conclusion = (TreeSet) conclusion.clone();</span>
<span class="fc bfc" id="L1005" title="All 2 branches covered.">                if (conclusion.contains(x)) {</span>
<span class="fc" id="L1006">                    conclusion.remove(x);</span>
<span class="fc" id="L1007">                    conclusion.addAll((TreeSet) red.get(x));</span>
<span class="fc" id="L1008">                    r2.addAllToConclusion(conclusion);</span>
<span class="fc" id="L1009">                    modif = true;</span>
                } else {
<span class="fc" id="L1011">                    r2.addAllToConclusion(conclusion);</span>
                }
                // replace the rule if modified
<span class="fc bfc" id="L1014" title="All 2 branches covered.">                if (modif) {</span>
<span class="pc bpc" id="L1015" title="1 of 2 branches missed.">                    if (truth.containsAll(r2.getConclusion())) {</span>
<span class="fc" id="L1016">                        this.removeRule(r); // Conclusions of this rule are always true, thus the rule is useless</span>
                    } else {
<span class="nc" id="L1018">                        this.replaceRule(r, r2);</span>
                    }
                } else {
<span class="fc bfc" id="L1021" title="All 2 branches covered.">                    if (truth.containsAll(r.getConclusion())) {</span>
<span class="fc" id="L1022">                        this.removeRule(r); // Conclusions of this rule are always true, thus the rule is useless</span>
                    }
                }
<span class="fc" id="L1025">            }</span>
            // remove the reducible elements from the elements set
<span class="fc" id="L1027">            this.deleteElement((Comparable) x);</span>
<span class="fc" id="L1028">        }</span>
<span class="fc" id="L1029">        return red;</span>
    }
    /**
     * Return true if this component is reduced.
     *
     * @return true if this component is reduced.
     */
    public boolean isReduced() {
        // Copy this component not to modify it
<span class="fc" id="L1038">        ImplicationalSystem tmp = new ImplicationalSystem(this);</span>
<span class="fc" id="L1039">        return tmp.reduction().isEmpty();</span>
    }

    /* --------------- IMPLEMENTATION OF CLOSURESYSTEM ABSTRACT METHODS ------------ */

    /**
     * Builds the closure of a set X of indexed elements.
     *
     * The closure is initialized with X. The closure is incremented with
     * the conclusion of each rule whose premise is included in it.
     * Iterations over the rules are performed until no new element has to be added
     * in the closure.
     *
     * For direct ImplicationalSystem, only one iteration is needed, and the treatment is
     * performed in O(|Sigma||S|).
     *
     * For non direct ImplicationalSystem, at most |S| iterations are needed, and this tratment
     * is performed in O(|Sigma||S|^2).
     *
     * @param   x  a TreeSet of indexed elements
     *
     * @return  the closure of X for this component
     */
    public TreeSet&lt;Comparable&gt; closure(TreeSet&lt;Comparable&gt; x) {
<span class="fc" id="L1063">        TreeSet&lt;Comparable&gt; oldES = new TreeSet&lt;Comparable&gt;();</span>
        // all the attributes are in their own closure
<span class="fc" id="L1065">        TreeSet&lt;Comparable&gt; newES = new TreeSet&lt;Comparable&gt;(x);</span>
        do {
<span class="fc" id="L1067">            oldES.addAll(newES);</span>
<span class="fc bfc" id="L1068" title="All 2 branches covered.">            for (Rule r : this.sigma) {</span>
<span class="pc bpc" id="L1069" title="1 of 4 branches missed.">                if (newES.containsAll(r.getPremise()) || r.getPremise().isEmpty()) {</span>
<span class="fc" id="L1070">                    newES.addAll(r.getConclusion());</span>
                }
<span class="fc" id="L1072">            }</span>
<span class="fc bfc" id="L1073" title="All 2 branches covered.">        } while (!(oldES.equals(newES)));</span>
<span class="fc" id="L1074">        return newES;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.0.201403182114</span></div></body></html>