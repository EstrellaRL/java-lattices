<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ConceptLattice.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Java Lattices</a> &gt; <a href="index.source.html" class="el_package">lattice</a> &gt; <span class="el_source">ConceptLattice.java</span></div><h1>ConceptLattice.java</h1><pre class="source lang-java linenums">package lattice;

/*
 * ConceptLattice.java
 *
 * last update on December 2013
 *
 */
import java.util.ArrayList;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;
import dgraph.DAGraph;
import dgraph.DGraph;
import dgraph.Edge;
import dgraph.Node;
/**
 * This class extends class `Lattice` to provide specific methods 
 * to manipulate both a concept lattice or a closed set lattice.
 *
 * This class provides methods implementing classical operation on a concept lattice:
 * join and meet reduction, concepts sets reduction, ...
 *
 * This class also provides two static method generating a concept lattice:
 * methods `diagramLattice` and `completeLattice` both computes
 * the closed set lattice of a given closure system.
 * The firt one computes the hasse diagram of the closed set lattice
 * by invoking  method `immediateSuccessors`. This method implements  an
 * adaptation of the well-known Bordat algorithm that also
 * computes the dependance graph of the lattice where at once the minimal generators and the canonical
 * direct basis of the lattice are encoded.
 * The second static method computes the transitively closure of the lattice
 * as the inclusion relation defined on all the closures
 * generated by method `allClosures` that implements
 * the well-known Wille algorithm.
 * 
 * Copyright: 2013 University of La Rochelle, France
 *
 * License: http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html CeCILL-B license
 *
 * This file is part of lattice, free package. You can redistribute it and/or modify
 * it under the terms of CeCILL-B license.
 *
 * @author Karell Bertet
 * @version 2013
 */
public class ConceptLattice extends Lattice {

	/* ------------- CONSTRUCTORS ------------------ */	
	/** Constructs this component with an empty set of nodes.*/     
	public ConceptLattice () { 
<span class="fc" id="L52">		super ();</span>
<span class="fc" id="L53">		}</span>
  	/** Constructs this component with the specified set of concepts,
	* and empty treemap of successors and predecessors 
	* @param S the set of nodes **/	
   public ConceptLattice (TreeSet&lt;Concept&gt; S) {
<span class="nc" id="L58">		super ((TreeSet)S);</span>
<span class="nc" id="L59">		}	</span>
	/**  Constructs this component as a shallow copy of the specified lattice.
	*
	* Concept lattice property is checked for the specified lattice.
	* When not verified, this component is constructed with an empty set of nodes. 
	* @param L the lattice to be copied */
	public ConceptLattice (Lattice L) {	
<span class="nc" id="L66">		super (L);</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">		if (!this.isConceptLattice()) { </span>
<span class="nc" id="L68">			this.setNodes(new TreeSet&lt;Node&gt;()); </span>
<span class="nc" id="L69">			this.setSuccessors(new TreeMap&lt;Node,TreeSet&lt;Edge&gt;&gt;());</span>
<span class="nc" id="L70">			this.setPredecessors(new TreeMap&lt;Node,TreeSet&lt;Edge&gt;&gt;());</span>
			}
<span class="nc" id="L72">		}</span>
	/* ------------- OVERLAPPING METHODS ------------------ */						
   /** Adds the specified node to the set of node of this component. 
	* In the case where content of this node is not a concept, 
	* the node will not be added */
    public boolean addNode (Node n) {
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">	 	if (n instanceof Concept)</span>
<span class="fc" id="L79">			return super.addNode(n); </span>
<span class="nc" id="L80">		else return false;</span>
	}
   /** Adds the specified edge to this component: 
	* `to` is added as a successor of `from`.
	* If the cases where specified nodes don't belongs to the node set, 
	* and where nodes don't contains concept as content, 
	* then the edge will not be added.
	* @param from the node origine of the edge
	* @param to the node destination of the edge **/	 
   public boolean addEdge (Node from, Node to) {
<span class="nc bnc" id="L90" title="All 4 branches missed.">		if ((to instanceof Concept) &amp;&amp; (from instanceof Concept))</span>
<span class="nc" id="L91">			return super.addEdge(from,to);</span>
<span class="nc" id="L92">		else return false;</span>
	}
	/* ------------- CONCEPT LATTICE CHEKING METHOD ------------------ */						
 
 	/** Check if nodes of this component are concepts */
	public boolean containsConcepts () {
<span class="fc bfc" id="L98" title="All 2 branches covered.">		for (Node n : this.getNodes())</span>
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">			if (!(n instanceof Concept)) return false;</span>
<span class="fc" id="L100">		return true;	</span>
	} 
   /** Check if this component is a lattice whose nodes are concepts
	*/	
   public boolean isConceptLattice () {
<span class="nc bnc" id="L105" title="All 2 branches missed.">		if (!this.isLattice()) return false;</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">		if (!this.containsConcepts()) return false;</span>
<span class="nc" id="L107">		return true;</span>
	}
    /** Check if this component is a lattice whose nodes are concepts with non null set A
	*/
   public boolean containsAllSetA () {
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">        if (!this.containsConcepts()) return false;</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">        for (Node n : this.getNodes())</span>
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">            if (!((Concept)n).hasSetA()) return false;</span>
<span class="fc" id="L115">        return true;</span>
   }
   /** Check if this component is a lattice whose nodes are concepts with non null set A
	*/
   public boolean containsAllSetB () {
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">        if (!this.containsConcepts()) return false;</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">        for (Node n : this.getNodes())</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">            if (!((Concept)n).hasSetB()) return false;</span>
<span class="fc" id="L123">        return true;</span>
   }

    /** Returns a copy of this component composed of a copy of each concept and each edge **/
    public ConceptLattice copy() {
<span class="fc" id="L128">        ConceptLattice CL = new ConceptLattice();</span>
<span class="fc" id="L129">        TreeMap&lt;Concept,Concept&gt; copy = new TreeMap&lt;Concept,Concept&gt; ();</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">        for (Node n : this.getNodes()) {</span>
<span class="fc" id="L131">            Concept c = (Concept) n;</span>
<span class="fc" id="L132">            Concept c2 = c.copy();</span>
<span class="fc" id="L133">            copy.put(c,c2);</span>
<span class="fc" id="L134">            CL.addNode(c2);</span>
<span class="fc" id="L135">        }</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">        for (Edge ed : this.getEdges()) </span>
<span class="nc" id="L137">            CL.addEdge (new Edge (copy.get(ed.getFrom()), copy.get(ed.getTo()), ed.getContent()));</span>
<span class="fc" id="L138">        return CL;</span>
    }


   	/* ------------- SET A AND SET B HANDLING METHOD ------------------ */

   /** Replace set A in each concept of the lattice with the null value **/
   public boolean removeAllSetA () {
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (!this.containsConcepts()) return false;</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">        for (Node n : this.getNodes()) {</span>
<span class="nc" id="L148">             Concept c = (Concept) n;</span>
<span class="nc" id="L149">             c.putSetA(null);</span>
<span class="nc" id="L150">         }</span>
<span class="nc" id="L151">        return true;</span>
   }
   /** Replace set B in each concept of the lattice with the null value **/
   public boolean removeAllSetB () {
<span class="nc bnc" id="L155" title="All 2 branches missed.">        if (!this.containsConcepts()) return false;</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">        for (Node n : this.getNodes()) {</span>
<span class="nc" id="L157">             Concept c = (Concept) n;</span>
<span class="nc" id="L158">             c.putSetB(null);</span>
<span class="nc" id="L159">        }</span>
<span class="nc" id="L160">        return true;</span>
   }
   /** Replace null set A in each join irreducible concept with a set containing node ident **/
   public boolean initializeSetAForJoin () {
<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (!this.containsConcepts()) return false;</span>
<span class="nc" id="L165">        TreeSet&lt;Node&gt; JoinIrr = this.joinIrreducibles ();</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">        for (Node n : this.getNodes()) {</span>
<span class="nc" id="L167">            Concept c = (Concept) n;</span>
<span class="nc bnc" id="L168" title="All 4 branches missed.">            if (!c.hasSetA() &amp;&amp; JoinIrr.contains(c)) {</span>
<span class="nc" id="L169">                ComparableSet X = new ComparableSet();</span>
<span class="nc" id="L170">                X.add(new Integer(c.getIdentifier()));</span>
<span class="nc" id="L171">                c.putSetA(X);</span>
                }
<span class="nc" id="L173">            }</span>
<span class="nc" id="L174">        return true;</span>
   }
    /** Replace null set B in each meet irreducible concept with a set containing node ident **/
   public boolean initializeSetBForMeet () {
<span class="nc bnc" id="L178" title="All 2 branches missed.">        if (!this.containsConcepts()) return false;</span>
<span class="nc" id="L179">        TreeSet&lt;Node&gt; MeetIrr = this.meetIrreducibles ();</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">        for (Node n : this.getNodes()) {</span>
<span class="nc" id="L181">             Concept c = (Concept) n;</span>
<span class="nc bnc" id="L182" title="All 4 branches missed.">             if (!c.hasSetB() &amp;&amp; MeetIrr.contains(c)) {</span>
<span class="nc" id="L183">                ComparableSet X = new ComparableSet();</span>
<span class="nc" id="L184">                X.add(new Integer(c.getIdentifier()));</span>
<span class="nc" id="L185">                c.putSetB(X);</span>
             }
<span class="nc" id="L187">         }</span>
<span class="nc" id="L188">        return true;</span>
   }

/* --------------- INCLUSION REDUCTION METHODS ------------ */

	/** Replaces, if not empty, set A of each concept with the difference between itself
     * and set A of its predecessors ;
     * Then replaces, if not empty, set B of each concept by
	 * the difference between itself and set B of its successors
     **/
	public boolean makeInclusionReduction () {
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">        if (!this.containsConcepts()) return false;</span>
<span class="fc" id="L200">        boolean setA = this.containsAllSetA();</span>
<span class="fc" id="L201">        boolean setB = this.containsAllSetB();</span>
<span class="pc bpc" id="L202" title="3 of 4 branches missed.">        if (!setA &amp;&amp; !setB) return false;</span>
        // makes setA inclusion reduction
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">        if (setA) {</span>
            // computation of an inverse topological sort
<span class="fc" id="L206">            this.transpose();</span>
<span class="fc" id="L207">            ArrayList&lt;Node&gt; sort = this.topologicalSort();</span>
<span class="fc" id="L208">            this.transpose();</span>
            // reduction of set A
<span class="fc bfc" id="L210" title="All 2 branches covered.">            for (Node to : sort) {</span>
<span class="fc" id="L211">                Concept cto  = (Concept)to;</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">                for (Node from : this.getPredecessorNodes(to))  {</span>
<span class="nc" id="L213">                    Concept cfrom = (Concept)from;</span>
<span class="nc" id="L214">                    cto.getSetA().removeAll(cfrom.getSetA());</span>
<span class="nc" id="L215">                }</span>
<span class="fc" id="L216">            }</span>
        }
        // makes setB inclusion reduction
<span class="fc bfc" id="L219" title="All 2 branches covered.">        if (setB) {</span>
            // computation of a topological sort
<span class="fc" id="L221">            ArrayList&lt;Node&gt; sort = this.topologicalSort();</span>
            // reduction of set B
<span class="fc bfc" id="L223" title="All 2 branches covered.">            for (Node to : sort)	{</span>
<span class="fc" id="L224">                Concept cto  = (Concept)to;</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">                for (Node from : this.getSuccessorNodes(to))  {</span>
<span class="nc" id="L226">                    Concept cfrom = (Concept)from;</span>
<span class="nc" id="L227">                    cto.getSetB().removeAll(cfrom.getSetB());</span>
<span class="nc" id="L228">                }</span>
<span class="fc" id="L229">            }</span>
        }
<span class="fc" id="L231">        return true;</span>
	}

	/** Replaces set A of each join irreducible node by
	* the difference between itself and set A of the unique predecessor.
	* Others closed sets are replaced by an emptyset **/
	public boolean makeIrreduciblesReduction () {
        // make inclusion reduction
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">        if (this.makeInclusionReduction()) {</span>
        	// check if not set A reduced concepts are join irreducibles
            // and if not set B reduced concepts are meet irreducibles
<span class="fc" id="L242">            TreeSet&lt;Node&gt; JoinIrr = this.joinIrreducibles ();</span>
<span class="fc" id="L243">            TreeSet&lt;Node&gt; MeetIrr = this.meetIrreducibles ();</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">            for (Node n : this.getNodes()) {</span>
<span class="fc" id="L245">                Concept c = (Concept)n;</span>
<span class="pc bpc" id="L246" title="4 of 6 branches missed.">                if (c.hasSetA() &amp;&amp; !c.getSetA().isEmpty() &amp;&amp; !JoinIrr.contains(c))</span>
<span class="nc" id="L247">                    c.putSetA(new ComparableSet());</span>
<span class="pc bpc" id="L248" title="3 of 6 branches missed.">                if (c.hasSetB() &amp;&amp; !c.getSetB().isEmpty() &amp;&amp; !MeetIrr.contains(c))</span>
<span class="nc" id="L249">                    c.putSetB(new ComparableSet());</span>
<span class="fc" id="L250">            }</span>
        }
<span class="fc" id="L252">        return true; </span>
    }

    /** Returns a lattice where edges are valuated by the difference between
     * set A of two adjacent concepts */
	public boolean makeEdgeValuation () {
<span class="nc bnc" id="L258" title="All 2 branches missed.">        if (!this.containsConcepts()) return false;</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">		for (Node n1 : this.getNodes())</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">            for (Edge ed : this.getSuccessorEdges(n1))</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">             if (!ed.hasContent()) {</span>
<span class="nc" id="L262">                 Node n2 = ed.getTo();</span>
<span class="nc" id="L263">                 TreeSet diff = new TreeSet();</span>
<span class="nc" id="L264">                 diff.addAll (((Concept)n2).getSetA());</span>
<span class="nc" id="L265">                 diff.removeAll(((Concept)n1).getSetA());</span>
<span class="nc" id="L266">                 ed.setContent(diff);</span>
             }
<span class="nc" id="L268">       return true;</span>
    }


    /* --------------- LATTICE GENERATION METHODS ------------ */

	/** Returns a lattice where join irreducibles node's content
	* is replaced by the first element of set A.
	* Other nodes are replaced by a new comparable.
	*/
	public Lattice getJoinReduction () {
<span class="nc bnc" id="L279" title="All 2 branches missed.">        if (!this.containsConcepts()) return null;</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">        if (!this.containsAllSetA()) return null;</span>
<span class="nc" id="L281">		Lattice L = new Lattice ();</span>
		//ConceptLattice CSL = new ConceptLattice (this);
<span class="nc" id="L283">        ConceptLattice CSL = this.copy();</span>
<span class="nc" id="L284">		CSL.makeIrreduciblesReduction ();</span>
<span class="nc" id="L285">        TreeSet&lt;Node&gt; JoinIrr = CSL.joinIrreducibles ();</span>
		// addition to L of a comparable issued from each reduced closed set
<span class="nc" id="L287">		TreeMap&lt;Node,Node&gt; reduced = new TreeMap&lt;Node,Node&gt;();</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">		for (Node n : CSL.getNodes()) {</span>
<span class="nc" id="L289">            Concept c = (Concept) n;</span>
            Node nred;
<span class="nc bnc" id="L291" title="All 4 branches missed.">			if (c.hasSetA() &amp;&amp; JoinIrr.contains(n))</span>
<span class="nc" id="L292">				nred = new Node(c.getSetA().first());</span>
            else
<span class="nc" id="L294">                nred = new Node();</span>
<span class="nc" id="L295">            reduced.put(n, nred);</span>
<span class="nc" id="L296">        }</span>
        // addtion of nodes to L
<span class="nc bnc" id="L298" title="All 2 branches missed.">		for (Node n : CSL.getNodes())</span>
<span class="nc" id="L299">			L.addNode(reduced.get(n));</span>
		// addtion of edges to L
<span class="nc bnc" id="L301" title="All 2 branches missed.">		for (Node from : CSL.getNodes())</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">			for (Node to : CSL.getSuccessorNodes(from))</span>
<span class="nc" id="L303">				L.addEdge (reduced.get(from),reduced.get(to));</span>
<span class="nc" id="L304">		return L;</span>
	}

	/** Returns a lattice where meet irreducibles node's content  
	* is replaced by the first element of set B. 
	* Other nodes are replaced by a new comparable.
	*/
	public Lattice getMeetReduction () {
<span class="nc bnc" id="L312" title="All 2 branches missed.">        if (!this.containsConcepts()) return null;</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">        if (!this.containsAllSetB()) return null;</span>
<span class="nc" id="L314">		Lattice L = new Lattice ();</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">		if (!this.containsConcepts()) return L;			</span>
		//ConceptLattice CSL = new ConceptLattice (this);
<span class="nc" id="L317">        ConceptLattice CSL = this.copy();</span>
<span class="nc" id="L318">        CSL.makeIrreduciblesReduction ();</span>
<span class="nc" id="L319">		TreeSet&lt;Node&gt; MeetIrr = CSL.meetIrreducibles ();		</span>
		// addition to L of a comparable issued from each reduced closed set
<span class="nc" id="L321">		TreeMap&lt;Node,Node&gt; reduced = new TreeMap&lt;Node,Node&gt;();</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">		for (Node n : CSL.getNodes()) {</span>
<span class="nc" id="L323">            Concept c = (Concept)n;</span>
            Node nred;
<span class="nc bnc" id="L325" title="All 4 branches missed.">			if (c.hasSetB() &amp;&amp; MeetIrr.contains(n))</span>
<span class="nc" id="L326">				nred = new Node(c.getSetB().first());</span>
            else
<span class="nc" id="L328">                nred = new Node();</span>
<span class="nc" id="L329">            reduced.put(n, nred);</span>
<span class="nc" id="L330">		}</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">		for (Node n : CSL.getNodes())</span>
<span class="nc" id="L332">			L.addNode(reduced.get(n));</span>
		// addtion of edges to L
<span class="nc bnc" id="L334" title="All 2 branches missed.">		for (Node from : CSL.getNodes()) </span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">			for (Node to : CSL.getSuccessorNodes(from))</span>
<span class="nc" id="L336">				L.addEdge (reduced.get(from),reduced.get(to));	</span>
<span class="nc" id="L337">		return L;</span>
	}	
	/** Returns a lattice where each join irreducible concept
	* is replaced by a node containing the first element of set A,
	* and each meet irreducible concept is replaced by a node contining the first element of set B.
    * A concept that is at once join and meet irreducible is replaced by
    * a node containing the first element of set A and the first element of set B in a set.
	* Other nodes are replaced by an empty node.
	*/
	public Lattice getIrreduciblesReduction () {
<span class="fc" id="L347">		Lattice L = new Lattice ();</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">		if (!this.containsConcepts()) return L;			</span>
		//ConceptLattice CSL = new ConceptLattice (this);
<span class="fc" id="L350">        ConceptLattice CSL = this.copy();</span>
<span class="fc" id="L351">        CSL.makeIrreduciblesReduction ();</span>
<span class="fc" id="L352">		TreeSet&lt;Node&gt; JoinIrr = CSL.joinIrreducibles ();		</span>
<span class="fc" id="L353">		TreeSet&lt;Node&gt; MeetIrr = CSL.meetIrreducibles ();		</span>
		// addition to L of a comparable issued from each reduced closed set
<span class="fc" id="L355">		TreeMap&lt;Node,Node&gt; reduced = new TreeMap&lt;Node,Node&gt;();</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">		for (Node n : CSL.getNodes()) {</span>
<span class="fc" id="L357">            Concept c = (Concept) n;</span>
			// create a new Node with two indexed elements: the first of set A and the first of set B 
<span class="pc bpc" id="L359" title="4 of 8 branches missed.">			if (c.hasSetA() &amp;&amp; c.hasSetB() &amp;&amp; MeetIrr.contains(c) &amp;&amp; JoinIrr.contains(c)) {</span>
<span class="nc" id="L360">				TreeSet&lt;Comparable&gt; content = new TreeSet&lt;Comparable&gt;();</span>
<span class="nc" id="L361">				content.add(c.getSetA().first());</span>
<span class="nc" id="L362">				content.add(c.getSetB().first());</span>
<span class="nc" id="L363">				Node nred = new Node(content);</span>
<span class="nc" id="L364">				reduced.put(n, nred);</span>
<span class="nc" id="L365">			}			</span>
			// create a new Node with the first element of set A
<span class="pc bpc" id="L367" title="2 of 4 branches missed.">			else if (c.hasSetA() &amp;&amp; JoinIrr.contains(n)) {</span>
<span class="nc" id="L368">				Node nred = new Node(((Concept)n).getSetA().first());</span>
<span class="nc" id="L369">				reduced.put(n, nred);</span>
<span class="nc" id="L370">			}</span>
			// create a new Node with the first element of set A			
<span class="pc bpc" id="L372" title="1 of 4 branches missed.">			else if (c.hasSetB() &amp;&amp; MeetIrr.contains(n)) {</span>
<span class="nc" id="L373">				Node nred = new Node(((Concept)n).getSetB().first());</span>
<span class="nc" id="L374">				reduced.put(n, nred);</span>
<span class="nc" id="L375">			}</span>
			else
<span class="fc" id="L377">				reduced.put(n, new Node());</span>
<span class="fc" id="L378">        }</span>
        // addtion of nodes to L
<span class="fc bfc" id="L380" title="All 2 branches covered.">		for (Node n : CSL.getNodes())</span>
<span class="fc" id="L381">			L.addNode(reduced.get(n));</span>
		// addtion of edges to L	
<span class="fc bfc" id="L383" title="All 2 branches covered.">		for (Node from : CSL.getNodes()) </span>
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">			for (Node to : CSL.getSuccessorNodes(from))</span>
<span class="nc" id="L385">				L.addEdge (reduced.get(from),reduced.get(to));	</span>
<span class="fc" id="L386">		return L;</span>
	}

    /**
     * Generate the lattice composed of all the antichains of this component
     * ordered with the inclusion relation.
     *
     * This treatment is performed in O(??) by implementation of Nourine algorithm
     * that consists in a sequence of doubling intervals of nodes.
     *
     * @return  the concept lattice
     */
   public static ConceptLattice idealsLattice(DAGraph dag) {
<span class="nc bnc" id="L399" title="All 2 branches missed.">        if (!dag.isAcyclic()) {</span>
<span class="nc" id="L400">            return null;</span>
        }
        // initialize the poset of ideals with the emptyset
<span class="nc" id="L403">        ConceptLattice conceptLattice = new ConceptLattice();</span>
<span class="nc" id="L404">        int id = 1;</span>
<span class="nc" id="L405">        conceptLattice.addNode(new Concept(true, false));</span>
        // travel on graph according to a topological sort
<span class="nc" id="L407">        DAGraph graph = new DAGraph(dag);</span>
<span class="nc" id="L408">        graph.transitiveClosure();</span>
        // treatment of nodes according to a topological sort
<span class="nc" id="L410">        ArrayList&lt;Node&gt; sort = graph.topologicalSort();</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">        for (Node x : sort) {</span>
            // computation of Jx
<span class="nc" id="L413">            TreeSet&lt;Node&gt; jxmoins = new TreeSet&lt;Node&gt;(graph.getPredecessorNodes(x));</span>
            // storage of new ideals in a set
<span class="nc" id="L415">            TreeSet&lt;Concept&gt; toAdd = new TreeSet&lt;Concept&gt;();</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">            for (Node j1 : conceptLattice.getNodes()) {</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">                if (((Concept) j1).containsAllInA(jxmoins)) {</span>
<span class="nc" id="L418">                     Concept newJ = new Concept(true, false);</span>
<span class="nc" id="L419">                     newJ.addAllToA(((TreeSet) ((Concept) j1).getSetA()));</span>
<span class="nc" id="L420">                     newJ.addToA(x);</span>
<span class="nc" id="L421">                     toAdd.add(newJ);</span>
                }
<span class="nc" id="L423">            }</span>
            // addition of the new ideals in conceptLattice
<span class="nc bnc" id="L425" title="All 2 branches missed.">            for (Concept newJ : toAdd) {</span>
<span class="nc" id="L426">                conceptLattice.addNode(newJ);</span>
<span class="nc" id="L427">            }</span>
<span class="nc" id="L428">        }</span>
        // computation of the inclusion relaton
<span class="nc bnc" id="L430" title="All 2 branches missed.">        for (Node node1 : conceptLattice.getNodes()) {</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">            for (Node node2 : conceptLattice.getNodes()) {</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">                if (((Concept) node1).containsAllInA(((Concept) node2).getSetA())) {</span>
<span class="nc" id="L433">                    conceptLattice.addEdge(node2, node1);</span>
                }
<span class="nc" id="L435">            }</span>
<span class="nc" id="L436">        }</span>
<span class="nc" id="L437">        conceptLattice.transitiveReduction();</span>
<span class="nc" id="L438">        return conceptLattice;</span>
    }

	/* -------- STATIC CLOSEDSET LATTICE GENERATION FROM AN IS OR A CONTEXT ------------------ */

  	/** Generates and returns the complete (i.e. transitively closed) closed set lattice of the
     * specified closure system, that can be an implicational system (IS) or a context.
     *
     * The lattice is generated using the well-known Next Closure algorithm.
     * All closures are first generated using the method:
     * `Vector&lt;Concept&gt; allClosures`
     * that implements the well-known Next Closure algorithm.
     * Then, all concepts are ordered by inclusion.
     *
     * @param init a closure system (an IS or a Context)
	 */
        public static ConceptLattice completeLattice (ClosureSystem init) {
<span class="nc" id="L455">            ConceptLattice L = new ConceptLattice();</span>
            // compute all the closed set with allClosures
<span class="nc" id="L457">            Vector&lt;Concept&gt; allclosure = init.allClosures();</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">            for (Concept cl : allclosure)</span>
<span class="nc" id="L459">    			L.addNode(cl);</span>

            // an edge corresponds to an inclusion between two closed sets
<span class="nc bnc" id="L462" title="All 2 branches missed.">        	for (Node from : L.getNodes())</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">            	for (Node to : L.getNodes())</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">                	if (((Concept)to).containsAllInA(((Concept)from).getSetA()))</span>
<span class="nc" id="L465">                       L.addEdge(from,to);            </span>
            // Hasse diagram is computed
<span class="nc" id="L467">        return L;</span>
    }

  	/** Generates and returns the Hasse diagram of the closed set lattice of the 
     * specified closure system, that can be an implicational system (IS) or a context.
     *
    * The Hasse diagramm of the closed set lattice is
     * obtained by a recursively generation of immediate successors of a given closed set,
     * starting from the botom closed set. Implemented algorithm is an adaptation of Bordat's
     * algorithm where the dependance graph is computed while the lattice is generated.
	 * This treatment is performed in O(cCl|S|^3log g) where S is the initial set of elements,
     * c is the number of closed sets that could be exponential in the worst case,
     * Cl is the closure computation complexity
     * and g is the number of minimal generators of the lattice.
     *
     * The dependance graph of the lattice is also computed while the lattice generation.
     * The dependance graph of a lattice encodes at once the minimal generators
     * and the canonical direct basis of the lattice .
     *
     * @param init a closure system (an IS or a Context)
     */
    public static ConceptLattice diagramLattice (ClosureSystem init) {
<span class="fc" id="L489">        ConceptLattice L = new ConceptLattice();</span>
        //if (Diagram) {
            // computes the dependance graph of the closure system
            // addition of nodes in the precedence graph
<span class="fc" id="L493">            DGraph graph = new DGraph();</span>
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">            for (Comparable c : init.getSet()) {</span>
<span class="nc" id="L495">                graph.addNode(new Node(c));</span>
<span class="nc" id="L496">            }</span>
<span class="fc" id="L497">            L.setDependencyGraph(graph);</span>
            // intialize the close set lattice with botom element
<span class="fc" id="L499">            Concept bot = new Concept (init.closure(new ComparableSet()), false);</span>
<span class="fc" id="L500">            L.addNode(bot);</span>
            // recursive genaration from the botom element with diagramLattice
<span class="fc" id="L502">            L.recursiveDiagramLattice(bot, init);</span>
            // minimalisation of edge's content to get only inclusion-minimal valuation for each edge
            /**for (Edge ed : L.dependanceGraph.getEdges()) {
                TreeSet&lt;ComparableSet&gt; valEd = new TreeSet&lt;ComparableSet&gt;(((TreeSet&lt;ComparableSet&gt;)ed.getContent()));
                for (ComparableSet X1 : valEd)
                    for (ComparableSet X2 : valEd)
                        if (X1.containsAll(X2) &amp;&amp; !X2.containsAll(X1))
                            ((TreeSet&lt;ComparableSet&gt;)ed.getContent()).remove(X1);
            }**/
<span class="fc" id="L511">        return L;</span>
        }

	/** Returns the Hasse diagramme of the closed set lattice of the specified closure system
     * issued from the specified concept.

     * Immediate successors generation is an adaptation of Bordat's theorem
    * stating that there is a bijection
    * between minimal strongly connected component of the precedence subgraph issued
	* from the specified node, and its immediate successors.
	*
	* This treatment is performed in O(cCl|S|^3log g) where S is the initial set of elements,
     * c is the number of closed sets that could be exponential in the worst case,
     * Cl is the closure computation complexity
     * and g is the number of minimal generators of the lattice.
	*/

	public void recursiveDiagramLattice (Concept n, ClosureSystem init) {
<span class="fc" id="L529">		Vector&lt;TreeSet&lt;Comparable&gt;&gt; immSucc = this.immediateSuccessors (n, init);</span>
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">		for (TreeSet&lt;Comparable&gt; X : immSucc) {</span>
<span class="nc" id="L531">            Concept c = new Concept(new TreeSet(X),false);</span>
<span class="nc" id="L532">            Concept ns = (Concept) this.getNode(c);</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">            if (ns != null)  // when ns already exists, addition of a new edge                </span>
<span class="nc" id="L534">				this.addEdge(n,ns);</span>
			else { // when ns don't already exists, addition of a new node and recursive treatment
<span class="nc" id="L536">				this.addNode(c);</span>
<span class="nc" id="L537">				this.addEdge (n,c);</span>
<span class="nc" id="L538">				this.recursiveDiagramLattice (c, init);</span>
			}
<span class="nc" id="L540">		}</span>
<span class="fc" id="L541">	}</span>

	/** Returns the list of immediate successors of a given node of the lattice.
	*
	* This treatment is an adaptation of Bordat's theorem stating that there is a bijection
    * between minimal strongly connected component of the precedence subgraph issued
	* from the specified node, and its immediate successors.
	*
	* This treatment is performed in O(Cl|S|^3log g) where S is the initial set of elements,
     * Cl is the closure computation complexity
     * and g is the number of minimal generators of the lattice.
     *
     * This treatment is recursively invoked by method recursiveDiagramlattice. In this case, the dependance graph
     * is initialized by method recursiveDiagramMethod, and updated by this method,
     * with addition some news edges and/or new valuations on existing edges.
     * When this treatment is not invoked by method recursiveDiagramLattice, then the dependance graph
     * is initialized, but it may be not complete. It is the case for example for on-line generation of the
     * concept lattice.
	*/
	public Vector&lt;TreeSet&lt;Comparable&gt;&gt; immediateSuccessors (Node n, ClosureSystem init) {
        // Initialization of the dependance graph when not initialized by method recursiveDiagramLattice
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">        if (!this.hasDependencyGraph()) {</span>
<span class="nc" id="L563">            DGraph graph = new DGraph();</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">            for (Comparable c : init.getSet()) {</span>
<span class="nc" id="L565">                graph.addNode(new Node(c));</span>
<span class="nc" id="L566">            }</span>
<span class="nc" id="L567">            this.setDependencyGraph(graph);            </span>
        }
        // computes newVal, the subset to be used to valuate every new dependance relation
        // newVal = F\predecessors of F in the precedence graph of the closure system
        // For a non reduced closure system, the precedence graph is not acyclic,
        // and therefore strongly connected components have to be used.
<span class="fc" id="L573">		ComparableSet F = new ComparableSet (((Concept)n).getSetA());        </span>
<span class="fc" id="L574">        DGraph prec = init.precedenceGraph();        </span>
<span class="fc" id="L575">        DAGraph acyclPrec = prec.getStronglyConnectedComponent();        </span>
<span class="fc" id="L576">        ComparableSet newVal = new ComparableSet ();</span>
<span class="fc" id="L577">        newVal.addAll(F);</span>
<span class="pc bpc" id="L578" title="1 of 2 branches missed.">        for (Object x : F)  {</span>
            // computes nx, the strongly connected component containing x
<span class="nc" id="L580">            Node nx = null;</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">            for (Node cc : acyclPrec.getNodes()) {</span>
<span class="nc" id="L582">                TreeSet&lt;Node&gt; CC = (TreeSet&lt;Node&gt;) cc.getContent();                </span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">                for (Node y : CC)</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">                    if (x.equals(y.getContent()))</span>
<span class="nc" id="L585">                        nx=cc;</span>
<span class="nc" id="L586">            }</span>
            // computes the minorants of nx in the acyclic graph
<span class="nc" id="L588">            TreeSet&lt;Node&gt; ccMinNx = acyclPrec.minorants(nx);</span>
            // removes from newVal every minorants of nx
<span class="nc bnc" id="L590" title="All 2 branches missed.">            for (Node cc : ccMinNx) {</span>
<span class="nc" id="L591">                TreeSet&lt;Node&gt; CC = (TreeSet&lt;Node&gt;) cc.getContent();</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">                for (Node y : CC)</span>
<span class="nc" id="L593">                    newVal.remove(y.getContent());</span>
<span class="nc" id="L594">            }</span>
<span class="nc" id="L595">        }</span>
        // computes the node belonging in S\F
<span class="fc" id="L597">        TreeSet&lt;Node&gt; N = new TreeSet&lt;Node&gt; ();        </span>
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">        for (Node in : this.getDependencyGraph().getNodes())</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">            if (!F.contains(in.getContent()))</span>
<span class="nc" id="L600">                N.add(in);</span>
        // computes the dependance relation between nodes in S\F
        // and valuated this relation by the subset of S\F
<span class="fc" id="L603">        TreeSet&lt;Edge&gt; E = new TreeSet&lt;Edge&gt;();</span>
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">        for (Node from : N)</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">            for (Node to : N)</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">               if (!from.equals(to)) {</span>
                // check if from is in dependance relation with to
                // i.e. &quot;from&quot; belongs to the closure of &quot;F+to&quot;
<span class="nc" id="L609">                ComparableSet FPlusTo = new ComparableSet(F);</span>
<span class="nc" id="L610">                FPlusTo.add(to.getContent());</span>
<span class="nc" id="L611">                FPlusTo = new ComparableSet(init.closure(FPlusTo));</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">                if (FPlusTo.contains(from.getContent())) {</span>
                    // there is a dependance relation between from and to
                    // search for an existing edge between from and to
<span class="nc" id="L615">                    Edge ed = this.getDependencyGraph().getEdge(from, to);</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">                    if (ed==null) {</span>
<span class="nc" id="L617">                        ed = new Edge (from,to,new TreeSet&lt;ComparableSet&gt;());</span>
<span class="nc" id="L618">                        this.getDependencyGraph().addEdge(ed);</span>
                    }
<span class="nc" id="L620">                    E.add(ed);</span>
                    // check if F is a minimal set closed for dependance relation between from and to
<span class="nc" id="L622">                    ((TreeSet&lt;ComparableSet&gt;)ed.getContent()).add(newVal);</span>
<span class="nc" id="L623">                    TreeSet&lt;ComparableSet&gt; ValEd = new TreeSet&lt;ComparableSet&gt;((TreeSet&lt;ComparableSet&gt;)ed.getContent());</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">                        for (ComparableSet X1 : ValEd) {</span>
<span class="nc bnc" id="L625" title="All 4 branches missed.">                            if (X1.containsAll(newVal) &amp;&amp; !newVal.containsAll(X1))</span>
<span class="nc" id="L626">                                ((TreeSet&lt;ComparableSet&gt;)ed.getContent()).remove(X1);</span>
<span class="nc bnc" id="L627" title="All 4 branches missed.">                            if (!X1.containsAll(newVal) &amp;&amp; newVal.containsAll(X1))</span>
<span class="nc" id="L628">                                ((TreeSet&lt;ComparableSet&gt;)ed.getContent()).remove(newVal);</span>
<span class="nc" id="L629">                        }</span>
                  }
               }
        // computes the dependance subgraph of the closed set F as the reduction
        // of the dependance graph composed of nodes in S\A and edges of the dependance relation
<span class="fc" id="L634">        DGraph sub = this.getDependencyGraph().getSubgraphByNodes(N);</span>
<span class="fc" id="L635">        DGraph delta = sub.getSubgraphByEdges(E);</span>
        // computes the sources of the CFC of the dependance subgraph
        // that corresponds to successors of the closed set F
<span class="fc" id="L638">		DAGraph CFC = delta.getStronglyConnectedComponent();</span>
<span class="fc" id="L639">		TreeSet&lt;Node&gt; SCCmin = CFC.getSinks();</span>
<span class="fc" id="L640">        Vector&lt;TreeSet&lt;Comparable&gt;&gt; immSucc = new Vector&lt;TreeSet&lt;Comparable&gt;&gt;();</span>
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">        for (Node n1 : SCCmin) {</span>
<span class="nc" id="L642">			TreeSet s = new TreeSet(F);</span>
<span class="nc" id="L643">			TreeSet&lt;Node&gt; toadd = (TreeSet&lt;Node&gt;)n1.getContent();</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">			for (Node n2 : toadd)</span>
<span class="nc" id="L645">				s.add(n2.getContent());</span>
<span class="nc" id="L646">			immSucc.add(s);</span>
<span class="nc" id="L647">		}</span>
<span class="fc" id="L648">       return immSucc;</span>
	}
}// end of ConceptLattice
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312101107</span></div></body></html>