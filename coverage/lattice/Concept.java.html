<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Concept.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Java Lattices</a> &gt; <a href="index.source.html" class="el_package">lattice</a> &gt; <span class="el_source">Concept.java</span></div><h1>Concept.java</h1><pre class="source lang-java linenums">package lattice;

/*
 * Concept.java
 *
 * last update on March 2010
 *
 */

import java.util.ArrayList;
import java.util.Iterator;
import java.util.StringTokenizer;
import java.util.TreeSet;
import dgraph.Node;
import dgraph.DGraph;
import dgraph.DAGraph;
import dgraph.Edge;

/**
 * This class gives a representation for a concept, i.e. a node of a concept lattice.
 *
 * A concept extends class `Node` by providing two comparable sets defined
 * by `ComparableSet`, namely setA and setB, aiming at storing set of a concepts.
 *
 * This component can also be used to store a closed set by using only set A.
 *
 * This class implements class `Comparable` aiming at
 * sorting concepts by providing the `compareTo()` method.
 * Comparison between this component and those in parameter is realised by comparing set A.
 *
 * Copyright: 2013 University of La Rochelle, France
 *
 * License: http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html CeCILL-B license
 *
 * This file is part of lattice, free package. You can redistribute it and/or modify
 * it under the terms of CeCILL-B license.
 *
 * @author Karell Bertet
 * @version 2013
 */
public class Concept extends Node {
    /* ------------- FIELDS ------------------ */

    /** This first set of comparable elements of the concept. **/
    private ComparableSet setA;
    /** This second set of comparable elements of the concept. **/
    private ComparableSet setB;

    /* ------------- CONSTRUCTORS ------------------ */
    /** Constructs a new concept containing the specified comparables set as setA and setB.
     * @param setA set of comparable used to initialise setA.
     * @param setB set of comparable used to initialise setB.
     **/
<span class="fc" id="L54">    public Concept(TreeSet&lt;Comparable&gt; setA, TreeSet&lt;Comparable&gt; setB) {</span>
<span class="fc" id="L55">            this.setA = new ComparableSet(setA);</span>
<span class="fc" id="L56">            this.setB = new ComparableSet(setB);</span>
<span class="fc" id="L57">        }</span>
    /** Constructs a new concept with an empty set of comparableset as setA and set B if the two boolean are true.
     * False booleans allow to construct a concept with only one of the two sets.
     * @param setA : field setA is empty if true, setA is null if false.
     * @param setB : field setB is empty if true, setB is null if false.
     **/
<span class="fc" id="L63">    public Concept(boolean setA, boolean setB) {</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">        if (setA) {</span>
<span class="fc" id="L65">            this.setA = new ComparableSet();</span>
        } else {
<span class="fc" id="L67">            this.setA = null;</span>
        }
<span class="fc bfc" id="L69" title="All 2 branches covered.">        if (setB) {</span>
<span class="fc" id="L70">            this.setB = new ComparableSet();</span>
        } else {
<span class="fc" id="L72">            this.setB = null;</span>
        }
<span class="fc" id="L74">        }</span>
    /** Constructs a new concept containing the specified comparables set as setA, and an empty set of comparableset as setB if the boolean is true.
     * A false boolean allows to construct a concept with the only set A.
     * @param setA set of comparable used to initialise setA.
     * @param setB : field setB is empty if true, setB is null if false.
     **/
<span class="fc" id="L80">        public Concept(TreeSet&lt;Comparable&gt; setA, boolean setB) {</span>
<span class="fc" id="L81">            this.setA = new ComparableSet(setA);</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">        if (setB) {</span>
<span class="fc" id="L83">            this.setB = new ComparableSet();</span>
        } else {
<span class="fc" id="L85">            this.setB = null;</span>
        }
<span class="fc" id="L87">        }</span>
    /** Constructs a new concept containing the specified comparables set as setB, and an empty set of comparableset as setA if the boolean is true.
     * A false boolean allows to construct concept with the only set B.
     * @param setA : field setA is empty if true, setA is null if false.
     * @param setB set of comparable used to initialise setB.
     **/
<span class="fc" id="L93">        public Concept(boolean setA, TreeSet&lt;Comparable&gt; setB) {</span>
<span class="fc" id="L94">            this.setB = new ComparableSet(setB);</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">            if (setA) {</span>
<span class="fc" id="L96">                this.setA = new ComparableSet();</span>
            } else {
<span class="fc" id="L98">                this.setA = null;</span>
            }
<span class="fc" id="L100">        }</span>
        /**  Constructs this component as a copy of the specified ClosedSet.
         * @param c the closed set to be copied
         **/
<span class="fc" id="L104">        public Concept(Concept c) {</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">        if (c.hasSetA()) {</span>
<span class="fc" id="L106">            this.setA = new ComparableSet(c.getSetA());</span>
        } else {
<span class="fc" id="L108">            this.setA = null;</span>
        }
<span class="fc bfc" id="L110" title="All 2 branches covered.">        if (c.hasSetB()) {</span>
<span class="fc" id="L111">            this.setB = new ComparableSet(c.getSetB());</span>
        } else {
<span class="fc" id="L113">            this.setB = null;</span>
        }
<span class="fc" id="L115">        }</span>
        /* --------------- ACCESSOR AND OVERLAPPING METHODS ------------ */

    /** Returns a copy of this component.
     * @return a copy of this componenet
     **/
    public Concept copy() {
<span class="fc bfc" id="L122" title="All 4 branches covered.">        if (this.hasSetA() &amp;&amp; this.hasSetB()) {</span>
<span class="fc" id="L123">            TreeSet setA = (TreeSet) this.getSetA().clone();</span>
<span class="fc" id="L124">            TreeSet setB = (TreeSet) this.getSetB().clone();</span>
<span class="fc" id="L125">            return new Concept(setA, setB);</span>
        }
<span class="pc bpc" id="L127" title="1 of 4 branches missed.">        if (this.hasSetA() &amp;&amp; !this.hasSetB()) {</span>
<span class="fc" id="L128">            TreeSet setA = (TreeSet) this.getSetA().clone();</span>
<span class="fc" id="L129">            return new Concept(setA, false);</span>
        } else {
<span class="fc bfc" id="L131" title="All 2 branches covered.">            if (this.hasSetB()) {</span>
<span class="fc" id="L132">                TreeSet setB = (TreeSet) this.getSetB().clone();</span>
<span class="fc" id="L133">                return new Concept(false, setB);</span>
            } else {
<span class="fc" id="L135">                return new Concept(false, false);</span>
            }
        }
    }

    /** Cheks if the concept has an empty set B.
     * @return true if and only if setB is not null
     */
    public boolean hasSetB() {
<span class="fc bfc" id="L144" title="All 2 branches covered.">        return this.setB != null;</span>
    }
    /** Cheks if the concept has an empty set A.
     * @return true if and only if setA is not null
     */
    public boolean hasSetA() {
<span class="fc bfc" id="L150" title="All 2 branches covered.">        return this.setA != null;</span>
    }
    /** Returns the set A of this component.
     * @return the set A of this component
     */
    public TreeSet&lt;Comparable&gt; getSetA() {
<span class="fc" id="L156">        return this.setA;</span>
    }
    /** Returns the set B of comparable of this component.
     * @return the set B of this component
     */
    public TreeSet&lt;Comparable&gt; getSetB() {
<span class="fc" id="L162">        return this.setB;</span>
    }
    /** Checks if the set A contains the specified comparable.
     * @param x comparable to find in setA.
     * @return true if and only if setA contains x.
     */
    public boolean containsInA(Comparable x) {
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (this.hasSetA()) {</span>
<span class="fc" id="L170">            return this.setA.contains(x);</span>
        } else {
<span class="fc" id="L172">            return false;</span>
        }
    }
    /** Checks if the set B contains the specified comparable.
     * @param x comparable to find in setB.
     * @return true if and only if setB contains x.
     */
    public boolean containsInB(Comparable x) {
<span class="fc bfc" id="L180" title="All 2 branches covered.">        if (this.hasSetB()) {</span>
<span class="fc" id="L181">            return this.setB.contains(x);</span>
        } else {
<span class="fc" id="L183">            return false;</span>
        }
    }
    /** Checks if the set A contains the specified set of comparable.
     * @param x set of comparable to find in setA.
     * @return true if and only if setA contains all elemens of x.
     */
    public boolean containsAllInA(TreeSet x) {
<span class="fc bfc" id="L191" title="All 2 branches covered.">        if (this.hasSetA()) {</span>
<span class="fc" id="L192">            return this.setA.containsAll(x);</span>
        } else {
<span class="fc" id="L194">            return false;</span>
        }
    }
    /** Checks if the set B contains the specified set of comparable.
     * @param x set of comparable to find in setB.
     * @return true if and only if setB contains all elemens of x.
     */
    public boolean containsAllInB(TreeSet x) {
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (this.hasSetB()) {</span>
<span class="fc" id="L203">            return this.setB.containsAll(x);</span>
        } else {
<span class="fc" id="L205">            return false;</span>
        }
        }
    /** Replaces the set A of this component by the specified one.
     * @param x set of comparable used to replace setB
     */
    public void putSetB(ComparableSet x) {
<span class="fc bfc" id="L212" title="All 2 branches covered.">        if (this.hasSetB()) {</span>
<span class="fc" id="L213">            this.setB = x;</span>
        } else {
<span class="fc" id="L215">            this.setB = new ComparableSet(x);</span>
        }
<span class="fc" id="L217">    }</span>
    /** Replaces the set A of this component by the specified one.
     * @param x set of comparable used to replace setA
     */
    public void putSetA(ComparableSet x) {
<span class="fc bfc" id="L222" title="All 2 branches covered.">        if (this.hasSetA()) {</span>
<span class="fc" id="L223">            this.setA = x;</span>
        } else {
<span class="fc" id="L225">            this.setA = new ComparableSet(x);</span>
        }
<span class="fc" id="L227">        }</span>
    /** Adds a comparable to the set A.
     * @param x comparable to add to setA
     * @return true if and only if addition is successful.
     */
    public boolean addToA(Comparable x) {
<span class="fc bfc" id="L233" title="All 2 branches covered.">        if (this.hasSetA()) {</span>
<span class="fc" id="L234">                    return this.setA.add(x);</span>
                } else {
<span class="fc" id="L236">                    return false;</span>
                }
        }
        /** Adds a comparable to the set B.
         * @param x comparable to add to setB
         * @return true if and only if addition is successful.
         */
    public boolean addToB(Comparable x) {
<span class="fc bfc" id="L244" title="All 2 branches covered.">        if (this.hasSetB()) {</span>
<span class="fc" id="L245">            return this.setB.add(x);</span>
        } else {
<span class="fc" id="L247">            return false;</span>
        }
        }
    /** Adds the specified set of comparable to the set A.
     * @param x set of comparable to add to setA
     * @return true if and only if addition is successful.
     */
    public boolean addAllToA(TreeSet x) {
<span class="fc bfc" id="L255" title="All 2 branches covered.">            if (this.hasSetA()) {</span>
<span class="fc" id="L256">                return this.setA.addAll(x);</span>
            } else {
<span class="fc" id="L258">                    return false;</span>
                }
        }
    /** Adds the specified set of comparable to the set B.
     * @param x set of comparable to add to setB
     * @return true if and only if addition is successful.
     */
    public boolean addAllToB(TreeSet x) {
<span class="fc bfc" id="L266" title="All 2 branches covered.">        if (this.hasSetB()) {</span>
<span class="fc" id="L267">            return this.setB.addAll(x);</span>
        } else {
<span class="fc" id="L269">            return false;</span>
        }
        }
    /** Remove a comparable from the set A.
     * @param x comparable to remove from setA
     * @return true if and only if removal is successful.
     */
    public boolean removeFromA(Comparable x) {
<span class="fc bfc" id="L277" title="All 2 branches covered.">            if (this.hasSetA()) {</span>
<span class="fc" id="L278">                return this.setA.remove(x);</span>
            } else {
<span class="fc" id="L280">                    return false;</span>
                }
        }
    /** Remove a comparable from the set B.
     * @param x comparable to remove from setB
     * @return true if and only if removal is successful.
     */
    public boolean removeFromB(Comparable x) {
<span class="fc bfc" id="L288" title="All 2 branches covered.">        if (this.hasSetB()) {</span>
<span class="fc" id="L289">            return this.setB.remove(x);</span>
        } else {
<span class="fc" id="L291">            return false;</span>
        }
        }
        /** Remove a set of comparable from the set A.
         * @param x set to remove from setA
         * @return true if and only if removal is successful.
         */
    public boolean removeAllFromA(TreeSet x) {
<span class="fc bfc" id="L299" title="All 2 branches covered.">            if (this.hasSetA()) {</span>
<span class="fc" id="L300">                    return this.setA.removeAll(x);</span>
                } else {
<span class="fc" id="L302">                    return false;</span>
                }
        }
    /** Remove a set of comparable from the set B.
     * @param x set to remove from setB
     * @return true if and only if removal is successful.
     */
    public boolean removeAllFromB(TreeSet x) {
<span class="fc bfc" id="L310" title="All 2 branches covered.">        if (this.hasSetB()) {</span>
<span class="fc" id="L311">            return this.setB.removeAll(x);</span>
        } else {
<span class="fc" id="L313">            return false;</span>
        }
        }
    /* --------------- OVERLAPPING METHODS ------------ */

    /** Returns the description of this component in a String without spaces.
     * @return the description of this component in a String without spaces.
     */
        public String toString() {
<span class="fc" id="L322">       String s = &quot;&quot;;</span>
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">       if (this.hasSetA()) {</span>
<span class="fc" id="L324">           s += this.setA;</span>
       }
<span class="pc bpc" id="L326" title="2 of 4 branches missed.">       if (this.hasSetA() &amp;&amp; this.hasSetB()) {</span>
<span class="fc" id="L327">           s += &quot;-&quot;;</span>
       }
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">       if (this.hasSetB()) {</span>
<span class="fc" id="L330">           s += this.setB;</span>
       }
<span class="fc" id="L332">       StringTokenizer st = new StringTokenizer(s);</span>
<span class="fc" id="L333">       s = &quot;&quot;;</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">       while (st.hasMoreTokens()) {</span>
<span class="fc" id="L335">                    s += st.nextToken();</span>
                }
<span class="fc" id="L337">       return s;</span>
    }

    /** Returns the dot description of this component in a String.
     * @return the dot description of this component in a String.
     */
        public String toDot() {
<span class="fc" id="L344">            String s = this.getIdentifier() + &quot; [label=\&quot; &quot;;</span>
<span class="fc" id="L345">            String tmp = &quot;&quot;;</span>
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">            if (this.hasSetA()) {</span>
<span class="fc" id="L347">                tmp += this.setA;</span>
            }
<span class="pc bpc" id="L349" title="2 of 4 branches missed.">            if (this.hasSetA() &amp;&amp; this.hasSetB()) {</span>
<span class="nc" id="L350">                tmp += &quot;\\n&quot;;</span>
            }
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">            if (this.hasSetB()) {</span>
<span class="nc" id="L353">                tmp += this.setB;</span>
            }
<span class="fc" id="L355">            StringTokenizer st = new StringTokenizer(tmp, &quot;\&quot;&quot;);</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">            while (st.hasMoreTokens()) {</span>
<span class="fc" id="L357">                s += st.nextToken();</span>
            }
<span class="fc" id="L359">            s += &quot;\&quot;]&quot;;</span>
<span class="fc" id="L360">            return s;</span>
        }
        /**
     * Returns the hash code of this component.
     *
     * @return  hash code of this component
     */
    public int hashCode() {
<span class="fc" id="L368">        return super.hashCode();</span>
    }
    /** Compares this component with the specified one.
     * @param o object compared to this component.
     * @return true if and only if o is equals to this component.
     */
    public boolean equals(Object o) {
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">        if (!(o instanceof Concept)) {</span>
<span class="nc" id="L376">            return false;</span>
        }
<span class="fc bfc" id="L378" title="All 2 branches covered.">        if (!this.hasSetB()) {</span>
<span class="fc" id="L379">            return this.setA.equals(((Concept) o).setA);</span>
        }
<span class="fc bfc" id="L381" title="All 2 branches covered.">        if (!this.hasSetA()) {</span>
<span class="fc" id="L382">            return this.setB.equals(((Concept) o).setB);</span>
        }
<span class="pc bpc" id="L384" title="2 of 4 branches missed.">        return this.setA.equals(((Concept) o).setA) &amp;&amp; this.setB.equals(((Concept) o).setB);</span>
    }
        /** Compares this component with the specified one sorted by the lectic order.
         * @return a negative integer, zero, or a positive integer as this component is less than,
         * equal to, or greater than the specified object.
         */
    /*public int compareTo(Object o){
    if (!(o instanceof lattice.Concept)) return -1;
    Concept c = (Concept) o;
    //System.out.println(&quot;compareTo : &quot;+this+&quot; &quot;+o);
    if (!this.hasSetB()) {
    return this.setA.compareTo(c.setA);
    }
    if (!this.hasSetA()) {
    return this.setB.compareTo(c.setB);
    }
    if (this.setA.compareTo(c.setA)!=0) {
    return this.setB.compareTo(c.setB);
    } else {
    return this.setA.compareTo(c.setA);
    }
    }*/
        /** Computes the immediate successors of this component with the LOA algorithm.
         *
         * @param init context from which successor of this component are computed.
         *
         * @return immediate successors of this component.
         */
        public ArrayList&lt;TreeSet&lt;Comparable&gt;&gt; immediateSuccessorsLOA(Context init) {
<span class="fc" id="L413">            ArrayList&lt;TreeSet&lt;Comparable&gt;&gt; succB = new ArrayList();</span>
<span class="fc" id="L414">            TreeSet&lt;Comparable&gt; attributes = (TreeSet&lt;Comparable&gt;) init.getSet().clone();</span>
<span class="fc" id="L415">            attributes.removeAll(this.getSetA());</span>

            boolean add;
<span class="fc bfc" id="L418" title="All 2 branches covered.">            for (Comparable x : attributes) {</span>
<span class="fc" id="L419">                add = true;</span>
<span class="fc" id="L420">                Iterator it = succB.iterator();</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">                while (it.hasNext()) {</span>
<span class="fc" id="L422">                    TreeSet tX = (TreeSet) it.next();</span>
<span class="fc" id="L423">                    TreeSet&lt;Comparable&gt; bx = (TreeSet&lt;Comparable&gt;) this.getSetA().clone();</span>
<span class="fc" id="L424">                    bx.add(x);</span>
<span class="fc" id="L425">                    TreeSet&lt;Comparable&gt; bX = (TreeSet&lt;Comparable&gt;) this.getSetA().clone();</span>
<span class="fc" id="L426">                    bX.addAll(tX);</span>
<span class="fc" id="L427">                    TreeSet&lt;Comparable&gt; bXx = (TreeSet&lt;Comparable&gt;) bX.clone();</span>
<span class="fc" id="L428">                    bXx.add(x);</span>
<span class="fc" id="L429">                    int cBx = count(init, bx);</span>
<span class="fc" id="L430">                    int cBX = count(init, bX);</span>
<span class="fc" id="L431">                    int cBXx = count(init, bXx);</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">                    if (cBx == cBX) {</span>
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">                        if (cBXx == cBx) {</span>
<span class="fc" id="L434">                            it.remove();</span>
<span class="fc" id="L435">                            TreeSet&lt;Comparable&gt; xx = new TreeSet();</span>
<span class="fc" id="L436">                            xx.addAll(tX);</span>
<span class="fc" id="L437">                            xx.add(x);</span>
<span class="fc" id="L438">                            succB.add(xx);</span>
<span class="fc" id="L439">                            add = false;</span>
<span class="fc" id="L440">                            break;</span>
                        }
                    }
<span class="nc bnc" id="L443" title="All 2 branches missed.">                    if (cBx &lt; cBX) {</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">                        if (cBXx == cBx) {</span>
<span class="nc" id="L445">                            add = false;</span>
<span class="nc" id="L446">                            break;</span>
                        }
                    }
<span class="nc bnc" id="L449" title="All 2 branches missed.">                    if (cBx &gt; cBX) {</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">                        if (cBXx == cBX) {</span>
<span class="nc" id="L451">                            it.remove();</span>
                        }
                    }
<span class="nc" id="L454">                }</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">                if (add) {</span>
<span class="fc" id="L456">                    TreeSet&lt;Comparable&gt; t = new TreeSet();</span>
<span class="fc" id="L457">                    t.add(x);</span>
<span class="fc" id="L458">                    succB.add(new TreeSet(t));</span>
                }
<span class="fc" id="L460">            }</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">            for (TreeSet t : succB) {</span>
<span class="fc" id="L462">                t.addAll(this.getSetA());</span>
<span class="fc" id="L463">            }</span>
<span class="fc" id="L464">            return succB;</span>
        }
        /** Returns the number of attributes in the init context.
         *
         * @param init : initial context from which attributes are count.
         * @param attributes : attributes to count.
         * @return number of attributes in init context.
         */
        private int count(Context init, TreeSet&lt;Comparable&gt; attributes) {
<span class="fc" id="L473">            return init.getExtentNb(attributes);</span>
        }
        /** Returns the list of immediate successors of a given node of the lattice.
         *
         * This treatment is an adaptation of Bordat's theorem stating that there is a bijection
         * between minimal strongly connected component of the precedence subgraph issued
         * from the specified node, and its immediate successors.
         *
         * This treatment is performed in O(Cl|S|^3log g) where S is the initial set of elements,
         * Cl is the closure computation complexity
         * and g is the number of minimal generators of the lattice.
         *
         * This treatment is recursively invoked by method recursiveDiagramlattice. In this case, the dependance graph
         * is initialized by method recursiveDiagramMethod, and updated by this method,
         * with addition some news edges and/or new valuations on existing edges.
         * When this treatment is not invoked by method recursiveDiagramLattice, then the dependance graph
         * is initialized, but it may be not complete. It is the case for example for on-line generation of the
         * concept lattice.
         *
         * cguerin - 2013-04-12 - transfer immedateSuccessors method from ConceptLattice to Concept
         *
         * @param init closure system used to compute immediate successors of this component.
         * @return the list of immediate successors of this component.
         */
        public ArrayList&lt;TreeSet&lt;Comparable&gt;&gt; immediateSuccessors(ClosureSystem init) {
            // Initialization of the dependance graph when not initialized by method recursiveDiagramLattice
<span class="fc" id="L499">            DGraph dependanceGraph = null;</span>
<span class="fc" id="L500">            dependanceGraph = new DGraph();</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">            for (Comparable c : init.getSet()) {</span>
<span class="fc" id="L502">                dependanceGraph.addNode(new Node(c));</span>
<span class="fc" id="L503">            }</span>
            // computes newVal, the subset to be used to valuate every new dependance relation
            // newVal = F\predecessors of F in the precedence graph of the closure system
            // For a non reduced closure system, the precedence graph is not acyclic,
            // and therefore strongly connected components have to be used.
<span class="fc" id="L508">            ComparableSet f = new ComparableSet(this.getSetA());</span>
<span class="fc" id="L509">            long start = System.currentTimeMillis();</span>
<span class="fc" id="L510">            System.out.print(&quot;Precedence graph... &quot;);</span>
<span class="fc" id="L511">            DGraph prec = init.precedenceGraph();</span>
<span class="fc" id="L512">            System.out.println(System.currentTimeMillis() - start + &quot;ms&quot;);</span>
<span class="fc" id="L513">            start = System.currentTimeMillis();</span>
<span class="fc" id="L514">            System.out.print(&quot;Srongly connected component... &quot;);</span>
<span class="fc" id="L515">            DAGraph acyclPrec = prec.getStronglyConnectedComponent();</span>
<span class="fc" id="L516">            System.out.println(System.currentTimeMillis() - start + &quot;ms&quot;);</span>
<span class="fc" id="L517">            ComparableSet newVal = new ComparableSet();</span>
<span class="fc" id="L518">            newVal.addAll(f);</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">            for (Object x : f)  {</span>
                // computes nx, the strongly connected component containing x
<span class="fc" id="L521">                Node nx = null;</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">                for (Node cc : acyclPrec.getNodes()) {</span>
<span class="fc" id="L523">                    TreeSet&lt;Node&gt; cC = (TreeSet&lt;Node&gt;) cc.getContent();</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">                    for (Node y : cC) {</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">                        if (x.equals(y.getContent())) {</span>
<span class="fc" id="L526">                            nx = cc;</span>
                        }
<span class="fc" id="L528">                    }</span>
<span class="fc" id="L529">                }</span>
                // computes the minorants of nx in the acyclic graph
<span class="fc" id="L531">                TreeSet&lt;Node&gt; ccMinNx = acyclPrec.minorants(nx);</span>
                // removes from newVal every minorants of nx
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">                for (Node cc : ccMinNx) {</span>
<span class="nc" id="L534">                    TreeSet&lt;Node&gt; cC = (TreeSet&lt;Node&gt;) cc.getContent();</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">                    for (Node y : cC) {</span>
<span class="nc" id="L536">                        newVal.remove(y.getContent());</span>
<span class="nc" id="L537">                    }</span>
<span class="nc" id="L538">                }</span>
<span class="fc" id="L539">            }</span>
            // computes the node belonging in S\F
<span class="fc" id="L541">            TreeSet&lt;Node&gt; n = new TreeSet&lt;Node&gt;();</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">            for (Node in : dependanceGraph.getNodes()) {</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">                if (!f.contains(in.getContent())) {</span>
<span class="fc" id="L544">                    n.add(in);</span>
                }
<span class="fc" id="L546">            }</span>
<span class="fc" id="L547">            System.out.print(&quot;Dependance... &quot;);</span>
<span class="fc" id="L548">            start = System.currentTimeMillis();</span>
            // computes the dependance relation between nodes in S\F
            // and valuated this relation by the subset of S\F
<span class="fc" id="L551">            TreeSet&lt;Edge&gt; e = new TreeSet&lt;Edge&gt;();</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">            for (Node from : n) {</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">                for (Node to : n) {</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">                   if (!from.equals(to)) {</span>
                    // check if from is in dependance relation with to
                    // i.e. &quot;from&quot; belongs to the closure of &quot;F+to&quot;
<span class="fc" id="L557">                    ComparableSet fPlusTo = new ComparableSet(f);</span>
<span class="fc" id="L558">                    fPlusTo.add(to.getContent());</span>
<span class="fc" id="L559">                    fPlusTo = new ComparableSet(init.closure(fPlusTo));</span>
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">                    if (fPlusTo.contains(from.getContent())) {</span>
                        // there is a dependance relation between from and to
                        // search for an existing edge between from and to
<span class="fc" id="L563">                        Edge ed = dependanceGraph.getEdge(from, to);</span>
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">                        if (ed == null) {</span>
<span class="fc" id="L565">                            ed = new Edge(from, to, new TreeSet&lt;ComparableSet&gt;());</span>
<span class="fc" id="L566">                            dependanceGraph.addEdge(ed);</span>
                        }
<span class="fc" id="L568">                        e.add(ed);</span>
                        // check if F is a minimal set closed for dependance relation between from and to
<span class="fc" id="L570">                        ((TreeSet&lt;ComparableSet&gt;) ed.getContent()).add(newVal);</span>
<span class="fc" id="L571">                        TreeSet&lt;ComparableSet&gt; valEd = new TreeSet&lt;ComparableSet&gt;((TreeSet&lt;ComparableSet&gt;) ed.getContent());</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">                            for (ComparableSet x1 : valEd) {</span>
<span class="pc bpc" id="L573" title="2 of 4 branches missed.">                                if (x1.containsAll(newVal) &amp;&amp; !newVal.containsAll(x1)) {</span>
<span class="nc" id="L574">                                    ((TreeSet&lt;ComparableSet&gt;) ed.getContent()).remove(x1);</span>
                                }
<span class="pc bpc" id="L576" title="3 of 4 branches missed.">                                if (!x1.containsAll(newVal) &amp;&amp; newVal.containsAll(x1)) {</span>
<span class="nc" id="L577">                                    ((TreeSet&lt;ComparableSet&gt;) ed.getContent()).remove(newVal);</span>
                                }
<span class="fc" id="L579">                            }</span>
                        }
                    }
<span class="fc" id="L582">                }</span>
<span class="fc" id="L583">            }</span>
<span class="fc" id="L584">            System.out.println(System.currentTimeMillis() - start + &quot;ms&quot;);</span>
<span class="fc" id="L585">            System.out.print(&quot;Subgraph... &quot;);</span>
<span class="fc" id="L586">            start = System.currentTimeMillis();</span>
            // computes the dependance subgraph of the closed set F as the reduction
            // of the dependance graph composed of nodes in S\A and edges of the dependance relation
<span class="fc" id="L589">            DGraph sub = dependanceGraph.getSubgraphByNodes(n);</span>
<span class="fc" id="L590">            DGraph delta = sub.getSubgraphByEdges(e);</span>
            // computes the sources of the CFC of the dependance subgraph
            // that corresponds to successors of the closed set F
<span class="fc" id="L593">            DAGraph cfc = delta.getStronglyConnectedComponent();</span>
<span class="fc" id="L594">            TreeSet&lt;Node&gt; sccmin = cfc.getSinks();</span>
<span class="fc" id="L595">            System.out.println(System.currentTimeMillis() - start + &quot;ms&quot;);</span>
<span class="fc" id="L596">            ArrayList&lt;TreeSet&lt;Comparable&gt;&gt; immSucc = new ArrayList&lt;TreeSet&lt;Comparable&gt;&gt;();</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">            for (Node n1 : sccmin) {</span>
<span class="fc" id="L598">                TreeSet s = new TreeSet(f);</span>
<span class="fc" id="L599">                TreeSet&lt;Node&gt; toadd = (TreeSet&lt;Node&gt;) n1.getContent();</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">                for (Node n2 : toadd) {</span>
<span class="fc" id="L601">                    s.add(n2.getContent());</span>
<span class="fc" id="L602">                }</span>
<span class="fc" id="L603">                immSucc.add(s);</span>
<span class="fc" id="L604">            }</span>
<span class="fc" id="L605">            return immSucc;</span>
        }
} // end of Concept
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312101107</span></div></body></html>