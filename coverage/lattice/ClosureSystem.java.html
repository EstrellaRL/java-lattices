<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ClosureSystem.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Java Lattices</a> &gt; <a href="index.source.html" class="el_package">lattice</a> &gt; <span class="el_source">ClosureSystem.java</span></div><h1>ClosureSystem.java</h1><pre class="source lang-java linenums">package lattice;

/*
 * ClosureSystem.java
 *
 * last update on December 2013
 *
 */
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;
import dgraph.DAGraph;
import dgraph.DGraph;
import dgraph.Node;
/**
 * This class is an abstract class defining the common behavior of closure systems,
 * and specialy its closed set lattice generation.
 *
 * Both a context and an implicational system have properties of a closure system,
 * and therefore extend this class.
 *
 * A closure system is formaly defined by a set of indexed elements and a closure operator
 * (abstract methods `getSet()` and `closure`). 
 * Abstract method  `toFile (String file)` also describe 
 * the common behavior of a closure system.
 *
 * However, this abstract class provides both abstract and non abstract methods. 
 * Although abstract methods depends on data, and so have to be implemented by each extended class, 
 * non abstract methods only used property of a closure system. It is the case for methods 
 * `nextClosure` (that computes the next closure of the specified one according to the lectic order
 * implemented the well-known Wille algorithm)
 * invoked by method `allClosure`
 * and the main method `closetSetLattice(boolean diagram)` (where lattice can be transitively closed or reduced).
 *
 * Copyright: 2013 University of La Rochelle, France
 *
 * License: http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html CeCILL-B license
 *
 * This file is part of lattice, free package. You can redistribute it and/or modify
 * it under the terms of CeCILL-B license.
 *
 * @author Karell Bertet
 * @version 2013
 */
<span class="fc" id="L45">public abstract class ClosureSystem {</span>

	/* ------------- ABSTRACT METHODS ------------------ */

    /** Returns the set of elements of the closure system */
    public abstract TreeSet&lt;Comparable&gt; getSet () ;

    /** Returns the closure of the specified set */
    public abstract TreeSet&lt;Comparable&gt; closure (TreeSet&lt;Comparable&gt; X) ;

    /** Saves this component in a file which name is specified **/
    public abstract void toFile (String file) ;

	/* ------------- IMPLEMENTED METHODS ------------------ */

    /** Returns the closed set lattice of this component.
    *
    * A true value of the boolean `diagram` indicates that the
     * Hasse diagramm of the lattice is computed (i.e. it is transitively reduced),
     * whereas a false value indicates that the lattice is transitively closed
     *
     * A transitively reduced lattice is generated by the static method
     * `ConceptLattice diagramLattice (ClosureSystem init)`
     * that implements an adaptation of Bordat's algorithm.
     * This adaptation computes the dependance graph while the lattice is generated,
     * with the same complexity.
     *
     * A transitively closed lattice is generated bye well-known Next Closure algorithm.
     * In this case, the dependance graph of the lattice isn't computed.
     *
     * @param diagram a boolean indicating if the Hasse diagramm of the lattice is computed or not.
	 **/
	public ConceptLattice closedSetLattice (boolean  diagram) {
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">        if (diagram)</span>
<span class="fc" id="L79">            return ConceptLattice.diagramLattice(this);</span>
        else
<span class="nc" id="L81">            return ConceptLattice.completeLattice(this);</span>
	}


   /** Returns all the closed sets of the specified closure system
    * (that can be an IS or a context).
    *
	* Closed sets are generated in lecticaly order, with the emptyset's closure
	* as first closed set, using the Ganter's Next Closure algorithm.
	*
    *  Therefore,
     * closed sets have to be comparable using `ComparableSet` class.
     * This treatment is performed in O(cCl|S|^3) where S is the initial set of elements,
     * c is the number of closed sets that could be exponential in the worst case,
     * and Cl is the closure computation complexity.
    *
	* @return all the closeds set in the lectically order.
	*/
	public Vector&lt;Concept&gt; allClosures (){
<span class="nc" id="L100">		Vector&lt;Concept&gt; allclosure = new Vector&lt;Concept&gt;();</span>
		// first closure: closure of the empty set
<span class="nc" id="L102">		allclosure.add(new Concept(this.closure(new ComparableSet()),false));</span>
<span class="nc" id="L103">		Concept cl = allclosure.firstElement();</span>
		// next closures in lectcally order
<span class="nc" id="L105">		boolean continu = true;</span>
        do {
<span class="nc" id="L107">            cl = this.nextClosure(cl);</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">            if (allclosure.contains(cl)) continu=false;</span>
<span class="nc" id="L109">            else allclosure.add(cl);</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">            } while (continu);</span>

<span class="nc" id="L112">        return allclosure;</span>
	}

	/** Returns the lecticaly next closed set of the specified one.
	*
	* This treatment is an implementation of the best knowm algorithm of Wille
	* whose complexity is in O(Cl|S|^2), where S is the initial set of elements,
     * and Cl is the closure computation complexity.
	* @return the lecticaly next closed set
	*/
	public Concept nextClosure (Concept cl) {
<span class="nc" id="L123">		TreeSet&lt;Comparable&gt; S = new TreeSet(this.getSet());</span>
<span class="nc" id="L124">		boolean success = false;</span>
<span class="nc" id="L125">		TreeSet A = new TreeSet(cl.getSetA());</span>
<span class="nc" id="L126">		Comparable ni = S.last();</span>
		do {
<span class="nc" id="L128">			ni = (Comparable)S.last();</span>
<span class="nc" id="L129">			S.remove(ni);</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">			if (!A.contains(ni)) {</span>
<span class="nc" id="L131">				A.add(ni);</span>
<span class="nc" id="L132">				TreeSet B = this.closure(A);</span>
<span class="nc" id="L133">				B.removeAll(A);</span>
<span class="nc bnc" id="L134" title="All 4 branches missed.">				if (B.isEmpty() || ((Comparable)B.first()).compareTo(ni)&gt;=1) {</span>
<span class="nc" id="L135">					A = this.closure(A);</span>
<span class="nc" id="L136">					success = true;</span>
				}
<span class="nc" id="L138">                else A.remove(ni);</span>
<span class="nc" id="L139">			}</span>
<span class="nc" id="L140">            else A.remove(ni);</span>
<span class="nc bnc" id="L141" title="All 4 branches missed.">		} while (!success &amp;&amp; ni.compareTo(this.getSet().first())&gt;=1);</span>
<span class="nc" id="L142">		return new Concept(A,false);</span>
	}


   /** Returns the precedence graph of this component.
   *
	* Nodes of the graph are elements of this component.
	* There is an edge from element a to element b when
    * b belongs to the closure of a.
    * When precedenc graph is acyclcic, then this component is a reduced one.    
	*/
	public DGraph precedenceGraph () {
        // compute a TreeMap of closures for each element of the component
<span class="fc" id="L155">        TreeMap&lt;Comparable,TreeSet&lt;Comparable&gt;&gt; Closures = new TreeMap&lt;Comparable,TreeSet&lt;Comparable&gt;&gt;();</span>
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">	for (Comparable x : this.getSet()) {</span>
<span class="nc" id="L157">            ComparableSet setX = new ComparableSet();</span>
<span class="nc" id="L158">            setX.add(x);        </span>
<span class="nc" id="L159">            Closures.put(x, this.closure(setX));</span>
<span class="nc" id="L160">        }</span>
        // nodes of the graph are elements
<span class="fc" id="L162">	DGraph prec = new DGraph();</span>
<span class="fc" id="L163">        TreeMap&lt;Comparable,Node&gt; nodeCreated = new TreeMap&lt;Comparable,Node&gt;();</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">	for (Comparable x : this.getSet()) {</span>
<span class="nc" id="L165">            Node n = new Node(x);</span>
<span class="nc" id="L166">            prec.addNode (n);</span>
<span class="nc" id="L167">            nodeCreated.put(x, n);</span>
<span class="nc" id="L168">        }        </span>
        // edges of the graph are closures containments
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        for (Comparable from : this.getSet())</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">            for (Comparable to : this.getSet())</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">               if (!from.equals(to)) {</span>
                // check if from belongs to the closure of to                
<span class="nc bnc" id="L174" title="All 2 branches missed.">                if (Closures.get(to).contains(from))</span>
<span class="nc" id="L175">                    prec.addEdge(nodeCreated.get(from), nodeCreated.get(to));</span>
               }
<span class="fc" id="L177">        return prec;</span>
	}
        
/*** 
* This function returns all reducible elements. 
* A reducible elements is equivalent by closure to one or more other attributes.
* Reducible elements are computed using the precedence graph of the closure system.
* Complexity is in O()
* @return The map of reduced attributes with their equivalent attributes
*/ 
public TreeMap&lt;Object, TreeSet&gt; getReducibleElements() {
        // Initialize a map Red of reducible attributes 
<span class="nc" id="L189">        TreeMap&lt;Object, TreeSet&gt; Red = new TreeMap();	</span>
	// Initialize the precedence graph G of the closure system
<span class="nc" id="L191">	DGraph G = this.precedenceGraph();                </span>
	// First, compute each group of equivalent attributes          
	// This group will be a strongly connected component on the graph. 
        // Then, only one element of each group	is skipped, others will be deleted. 
<span class="nc" id="L195">	DAGraph CFC = G.getStronglyConnectedComponent();                </span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">	for (Node C : CFC.getNodes()) {             </span>
            // Get list of node of this component             
<span class="nc" id="L198">            TreeSet&lt;Node&gt; sCC = (TreeSet) C.getContent(); </span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">            if (sCC.size() &gt; 1) {    </span>
<span class="nc" id="L200">		Node y = sCC.first(); </span>
<span class="nc" id="L201">		TreeSet yClass = new TreeSet ();</span>
<span class="nc" id="L202">                yClass.add(y.getContent());</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">		for (Node x : sCC) </span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">			if (!x.getContent().equals(y.getContent())) {                             			                         </span>
<span class="nc" id="L205">                            G.removeNode(x);</span>
<span class="nc" id="L206">                            Red.put(x.getContent(), yClass);                                    </span>
			}                 
            }
<span class="nc" id="L209">        }     </span>
        // Next, check if an attribute is equivalent to emptyset
        // i.e. its closure is equal to emptyset closure
<span class="nc" id="L212">        TreeSet &lt;Node&gt; sinks = G.getSinks();</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (sinks.size()==1) {</span>
<span class="nc" id="L214">            Node s = sinks.first();</span>
<span class="nc" id="L215">            Red.put (s.getContent(), new TreeSet());</span>
<span class="nc" id="L216">            G.removeNode(s);</span>
        }        
	// Finaly, checking a remaining attribute equivalent to its predecessors or not may reduce more attributes. 
	// Check all remaining nodes of graph G 
<span class="nc bnc" id="L220" title="All 2 branches missed.">	for (Node x : G.getNodes()) { 	            </span>
<span class="nc" id="L221">            TreeSet&lt;Node&gt; P = G.getPredecessorNodes(x);	                </span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">            if (P.size() &gt; 1) { </span>
                // Create the closure of x 
<span class="nc" id="L224">		TreeSet X = new TreeSet();</span>
<span class="nc" id="L225">                X.add(x.getContent());</span>
<span class="nc" id="L226">                TreeSet closureX = this.closure(X);                                                                        			</span>
		// Create the closure of P 						                        
<span class="nc" id="L228">                TreeSet&lt;Comparable&gt; Pred = new TreeSet &lt;Comparable&gt; ();</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">                for (Node n : P)</span>
<span class="nc" id="L230">                    Pred.add((Comparable)n.getContent());    </span>
<span class="nc" id="L231">                    TreeSet &lt;Comparable&gt; closureP = this.closure(Pred);                    </span>
                    // Check the equality of two closures 
<span class="nc bnc" id="L233" title="All 4 branches missed.">                    if (closureX.containsAll(closureP) &amp;&amp; closureP.containsAll(closureX))</span>
<span class="nc" id="L234">                        Red.put(x.getContent(),Pred);                    </span>
		} 
<span class="nc" id="L236">	} </span>
	// Finally, return the list of reducible elements with their equivalent attributes. 
<span class="nc" id="L238">	return Red; </span>
    } 
}// end of ClosureSystem
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312101107</span></div></body></html>