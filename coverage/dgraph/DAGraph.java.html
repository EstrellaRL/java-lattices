<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DAGraph.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Java Lattices</a> &gt; <a href="index.source.html" class="el_package">dgraph</a> &gt; <span class="el_source">DAGraph.java</span></div><h1>DAGraph.java</h1><pre class="source lang-java linenums">package dgraph;

/*
 * DAGraph.java
 *
 * Copyright: 2013 University of La Rochelle, France
 *
 * License: http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html CeCILL-B license
 *
 * This file is part of lattice, free package. You can redistribute it and/or modify
 * it under the terms of CeCILL-B license.
 *
 * @author Karell Bertet
 * @version 2014
 */

import java.util.ArrayList;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Set;

/**
 * This class extends the representation of a directed graph given by class
 * {@link DGraph} for directed acyclic graph (DAG).
 *
 * The main property of a directed acyclic graph is to be a partially ordered set (poset) when
 * transitively closed, and a Hasse diagram when transitively reduced.
 *
 * This property is not ensured for components of this class because it would require a
 * checking treatment over the graph whenever a new edge or node is added.
 * However, this property can be explicitely ckecked using method
 * {@link #isAcyclic}.
 *
 * This class provides methods implementing classical operation on a directed acyclic graph:
 * minorants and majorants, filter and ideal, transitive reduction, ideal lattice, ...
 *
 * This class also provides a static method randomly generating a directed acyclic graph,
 * and a static method generating the graph of divisors.
 *
 * ![DAGraph](DAGraph.png)
 *
 * @uml DAGraph.png
 *
 * DGraph &lt;|-- DAGraph
 *
 * class DAGraph {
 *      +DAGraph()
 *      +DAGraph(final Set&lt;Node&gt; set)
 *      +DAGraph(final DGraph graph)
 *
 *      +TreeSet&lt;Node&gt; min()
 *      +TreeSet&lt;Node&gt; max()
 *      +TreeSet&lt;Node&gt; majorants(final Node node)
 *      +TreeSet&lt;Node&gt; minorants(final Node node)
 *      +DAGraph filter(final Node node)
 *      +DAGraph ideal(final Node node)
 *      +DAGraph getSubgraphByNodes(final Set&lt;Node&gt; nodes)
 *
 *      +int transitiveReduction()
 *      +int transitiveClosure()
 *
 *      +{static}DAGraph divisors(int number)
 *      +{static}DAGraph random(int size, double threshold)
 *      +{static}DAGraph random(int size)
 * }
 *
 * class DGraph {
 *     -TreeSet&lt;Node&gt; nodes
 *     -TreeMap&lt;Node, TreeSet&lt;Edge&gt;&gt; successors
 *     -TreeMap&lt;Node, TreeSet&lt;Edge&gt;&gt; predecessors
 *
 *     +DGraph()
 *     +DGraph(final Set&lt;Node&gt; set)
 *     +DGraph(final DGraph graph)
 *
 *     +{static}DGraph random(int size, double threshold)
 *     +{static}DGraph random(int size)
 *
 *     +int sizeNodes()
 *     +int sizeEdges()
 *     +SortedSet&lt;Node&gt; getNodes()
 *     +SortedSet&lt;Edge&gt; getEdges()
 *     +SortedSet&lt;Edge&gt; getSuccessorEdges(final Node node)
 *     +SortedSet&lt;Edge&gt; getPredecessorEdges(final Node node)
 *     +TreeSet&lt;Node&gt; getSuccessorNodes(final Node node)
 *     +TreeSet&lt;Node&gt; getPredecessorNodes(final Node node)
 *     +Edge getEdge(final Node from, final Node to)
 *     +Node getNode(final Object search)
 *     +Node getNodeByContent(final Object content)
 *     +Node getNodeByIdentifier(int identifier)
 *     #DGraph setNodes(final TreeSet&lt;Node&gt; nodes)
 *     #TreeMap&lt;Node, TreeSet&lt;Edge&gt;&gt; getSuccessors()
 *     #DGraph setSuccessors(final TreeMap&lt;Node, TreeSet&lt;Edge&gt;&gt; successors)
 *     #TreeMap&lt;Node, TreeSet&lt;Edge&gt;&gt; getPredecessors()
 *     #DGraph setPredecessors(final TreeMap&lt;Node, TreeSet&lt;Edge&gt;&gt; predecessors)
 *
 *     +String toString()
 *     +void writeDot(final String filename)
 *
 *     +boolean containsNode(final Node node)
 *     +boolean addNode(final Node node)
 *     +boolean removeNode(final Node node)
 *     +boolean removeNodes(final Set&lt;Node&gt; nodes)
 *     +boolean containsEdge(final Node from, final Node to)
 *     +boolean containsEdge(final Edge edge)
 *     +boolean addEdge(final Node from, final Node to, final Object content)
 *     +boolean addEdge(final Node from, final Node to)
 *     +boolean addEdge(final Edge edge)
 *     +boolean removeEdge(final Node from, final Node to)
 *     +boolean removeEdge(final Edge edge)
 *
 *     +boolean isAcyclic()
 *
 *     +ArrayList&lt;Node&gt; topologicalSort()
 *     +TreeSet&lt;Node&gt; getSinks()
 *     +TreeSet&lt;Node&gt; getWells()
 *     +DGraph getSubgraphByNodes(final Set&lt;Node&gt; nodes)
 *     +DGraph getSubgraphByEdges(final Set&lt;Edge&gt; edges)
 *     +void complementary()
 *     +int reflexiveReduction()
 *     +int reflexiveClosure()
 *     +int transitiveClosure()
 *     +ArrayList&lt;Node&gt;[] depthFirstSearch(Node source, TreeSet&lt;Node&gt; visited, ArrayList&lt;Node&gt; sort)
 *     +ArrayList&lt;Node&gt;[] depthFirstSearch()
 *     +void transpose()
 *     +DAGraph getStronglyConnectedComponent()
 * }
 */
public class DAGraph extends DGraph {

    /**
     * Constructs a new DAG with an empty set of node.
     */
    public DAGraph() {
<span class="nc" id="L135">        super();</span>
<span class="nc" id="L136">    }</span>

    /**
     * Constructs this component with the specified set of nodes,
     * and empty treemap of successors and predecessors.
     *
     * @param   set  the set of nodes
     */
    public DAGraph(final Set&lt;Node&gt; set) {
<span class="nc" id="L145">        super(set);</span>
<span class="nc" id="L146">    }</span>

    /**
     * Constructs this component as a copy of the specified directed graph.
     *
     * Acyclic property is checked for the specified DAG.
     * When not verified, this component is construct with the same set of nodes but with no edges.
     *
     * @param   graph  the DGraph to be copied
     */
    public DAGraph(final DGraph graph) {
<span class="nc" id="L157">        super(graph);</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">        if (this.isAcyclic()) {</span>
<span class="nc" id="L159">            this.reflexiveReduction();</span>
        } else {
<span class="nc" id="L161">            TreeMap&lt;Node, TreeSet&lt;Edge&gt;&gt; successors = new TreeMap&lt;Node, TreeSet&lt;Edge&gt;&gt;();</span>
<span class="nc" id="L162">            TreeMap&lt;Node, TreeSet&lt;Edge&gt;&gt; predecessors = new TreeMap&lt;Node, TreeSet&lt;Edge&gt;&gt;();</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">            for (Node node : this.getNodes()) {</span>
<span class="nc" id="L164">                successors.put(node, new TreeSet&lt;Edge&gt;());</span>
<span class="nc" id="L165">                predecessors.put(node, new TreeSet&lt;Edge&gt;());</span>
<span class="nc" id="L166">            }</span>
<span class="nc" id="L167">            this.setSuccessors(successors);</span>
<span class="nc" id="L168">            this.setPredecessors(predecessors);</span>
        }
<span class="nc" id="L170">    }</span>

    /* --------------- DAG HANDLING METHODS ------------ */

    /**
     * Returns the minimal element of this component.
     *
     * @return  the minimal element
     */
    public TreeSet&lt;Node&gt; min() {
<span class="nc" id="L180">        return this.getSinks();</span>
    }

    /**
     * Returns the maximal element of this component.
     *
     * @return  the maximal element
     */
    public TreeSet&lt;Node&gt; max() {
<span class="nc" id="L189">        return this.getWells();</span>
    }

    /**
     * Returns the set of majorants of the specified node.
     *
     * Majorants of a node are its successors in the transitive closure
     *
     * @param   node  the specified node
     *
     * @return  the set of majorants
     */
    public TreeSet&lt;Node&gt; majorants(final Node node) {
<span class="nc" id="L202">        DAGraph graph = new DAGraph(this);</span>
<span class="nc" id="L203">        graph.transitiveClosure();</span>
<span class="nc" id="L204">        return graph.getSuccessorNodes(node);</span>
    }

    /**
     * Returns the set of minorants of the specified node.
     *
     * Minorants of a node are its predecessors in the transitive closure
     *
     * @param   node  the specified node
     *
     * @return  the set of minorants
     */
    public TreeSet&lt;Node&gt; minorants(final Node node) {
<span class="nc" id="L217">        DAGraph graph = new DAGraph(this);</span>
<span class="nc" id="L218">        graph.transitiveClosure();</span>
<span class="nc" id="L219">        return graph.getPredecessorNodes(node);</span>
    }

    /**
     * Returns the subgraph induced by the specified node and its successors
     * in the transitive closure.
     *
     * @param   node  the specified node
     *
     * @return  the subgraph
     */
    public DAGraph filter(final Node node) {
<span class="nc" id="L231">        TreeSet&lt;Node&gt; set = this.majorants(node);</span>
<span class="nc" id="L232">        set.add(node);</span>
<span class="nc" id="L233">        return this.getSubgraphByNodes(set);</span>
    }

    /**
     * Returns the subgraph induced by the specified node and its predecessors
     * in the transitive closure.
     *
     * @param   node the specified node
     *
     * @return  the subgraph
     */
    public DAGraph ideal(final Node node) {
<span class="nc" id="L245">        TreeSet&lt;Node&gt; set = this.minorants(node);</span>
<span class="nc" id="L246">        set.add(node);</span>
<span class="nc" id="L247">        return this.getSubgraphByNodes(set);</span>
    }

    /**
     * Returns the subgraph of this component induced by the specified set of nodes.
     *
     * The subgraph only contains nodes of the specified set that also are in this component.
     *
     * @param   nodes  The set of nodes
     *
     * @return  The subgraph
     */
    public DAGraph getSubgraphByNodes(final Set&lt;Node&gt; nodes) {
<span class="nc" id="L260">        DGraph tmp = new DGraph(this);</span>
<span class="nc" id="L261">        tmp.transitiveClosure();</span>
<span class="nc" id="L262">        DGraph sub = tmp.getSubgraphByNodes(nodes);</span>
<span class="nc" id="L263">        DAGraph sub2 = new DAGraph(sub);</span>
<span class="nc" id="L264">        sub2.transitiveReduction();</span>
<span class="nc" id="L265">        return sub2;</span>
    }

    /* --------------- DAG TREATMENT METHODS ------------ */

    /**
     * Computes the transitive reduction of this component.
     *
     * The transitive reduction is not uniquely defined only when the acyclic property
     * is verified. In this case, it corresponds to the Hasse diagram of the DAG.
     *
     * This method is an implementation of the Goralcikova-Koubeck
     * algorithm that can also compute the transitive closure.
     * This tratment is performed in O(n+nm_r+nm_c),
     * where n corresponds to the number of nodes,
     * m_r to the numer of edges in the transitive closure,
     * and m_r the number of edges in the transitive reduction.
     *
     * @return  the number of added edges
     */
    public int transitiveReduction() {

        // copy this component in a new DAG graph
<span class="nc" id="L288">        DAGraph graph = new DAGraph(this);</span>
<span class="nc" id="L289">        graph.reflexiveReduction();</span>
        // initalize this component with no edges
<span class="nc" id="L291">        this.setSuccessors(new TreeMap&lt;Node, TreeSet&lt;Edge&gt;&gt;());</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">        for (Node node : this.getNodes()) {</span>
<span class="nc" id="L293">            this.getSuccessors().put(node, new TreeSet&lt;Edge&gt;());</span>
<span class="nc" id="L294">        }</span>
<span class="nc" id="L295">        this.setPredecessors(new TreeMap&lt;Node, TreeSet&lt;Edge&gt;&gt;());</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">        for (Node node : this.getNodes()) {</span>
<span class="nc" id="L297">            this.getPredecessors().put(node, new TreeSet&lt;Edge&gt;());</span>
<span class="nc" id="L298">        }</span>
<span class="nc" id="L299">        int number = 0;</span>
        // mark each node to false
<span class="nc" id="L301">        TreeMap&lt;Node, Boolean&gt; mark = new TreeMap&lt;Node, Boolean&gt;();</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">        for (Node node : graph.getNodes()) {</span>
<span class="nc" id="L303">            mark.put(node, new Boolean(false));</span>
<span class="nc" id="L304">        }</span>
        // treatment of nodes according to a topological sort
<span class="nc" id="L306">        ArrayList&lt;Node&gt; sort = graph.topologicalSort();</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">        for (Node x : sort) {</span>
<span class="nc" id="L308">            TreeSet&lt;Node&gt; set = new TreeSet&lt;Node&gt;(graph.getSuccessorNodes(x));</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">            while (!set.isEmpty()) {</span>
                // compute the smallest successor y of x according to the topological sort
<span class="nc" id="L311">                int i = 0;</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">                while (!set.contains(sort.get(i))) {</span>
<span class="nc" id="L313">                    i++;</span>
                }
<span class="nc" id="L315">                Node y = sort.get(i);</span>
                // when y is not not marked, x-&gt;y is a reduced edge
<span class="nc bnc" id="L317" title="All 4 branches missed.">                if (y != null &amp;&amp; !mark.get(y).booleanValue()) {</span>
<span class="nc" id="L318">                    this.addEdge(x, y);</span>
<span class="nc" id="L319">                    graph.addEdge(x, y);</span>
                }
<span class="nc bnc" id="L321" title="All 2 branches missed.">                for (Node z : graph.getSuccessorNodes(y)) {</span>
                    // treatment of z when not marked
<span class="nc bnc" id="L323" title="All 2 branches missed.">                    if (!mark.get(z).booleanValue()) {</span>
<span class="nc" id="L324">                        mark.put(z, new Boolean(true));</span>
<span class="nc" id="L325">                        graph.addEdge(x, z);</span>
<span class="nc" id="L326">                        number++;</span>
<span class="nc" id="L327">                        set.add(z);</span>
                    }
<span class="nc" id="L329">                }</span>
<span class="nc" id="L330">                set.remove(y);</span>
<span class="nc" id="L331">            }</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">            for (Node y : graph.getSuccessorNodes(x)) {</span>
<span class="nc" id="L333">                mark.put(y, new Boolean(false));</span>
<span class="nc" id="L334">            }</span>
<span class="nc" id="L335">        }</span>
<span class="nc" id="L336">        return number;</span>
    }

   /**
    * Computes the transitive closure of this component.
    *
    * This method overlaps the computation of the transitive closure for directed graph
    * in class {@link DGraph} with an implementation of the Goralcikova-Koubeck
    * algorithm dedicated to acyclic directed graph. This algorithm can also compute the
    * transitive reduction of a directed acyclic graph.
    *
    * This treatment is performed in O(n+nm_r+nm_c), where n corresponds to the number of nodes,
    * m_r to the numer of edges in the transitive closure,
    * and m_r the number of edges in the transitive reduction.
    *
    * @return  the number of added edges
    */
   public int transitiveClosure() {
<span class="nc" id="L354">        int number = 0;</span>
        // mark each node to false
<span class="nc" id="L356">        TreeMap&lt;Node, Boolean&gt; mark = new TreeMap&lt;Node, Boolean&gt;();</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">        for (Node node : this.getNodes()) {</span>
<span class="nc" id="L358">            mark.put(node, new Boolean(false));</span>
<span class="nc" id="L359">        }</span>
        // treatment of nodes according to a topological sort
<span class="nc" id="L361">        ArrayList&lt;Node&gt; sort = this.topologicalSort();</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">        for (Node x : sort) {</span>
<span class="nc" id="L363">            TreeSet&lt;Node&gt; set = new TreeSet&lt;Node&gt;(this.getSuccessorNodes(x));</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">            while (!set.isEmpty()) {</span>
                // compute the smallest successor y of x according to the topological sort
<span class="nc" id="L366">                int i = 0;</span>
                do {
<span class="nc" id="L368">                    i++;</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">                } while (!set.contains(sort.get(i)));</span>
<span class="nc" id="L370">                Node y = sort.get(i);</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">                for (Node z : this.getSuccessorNodes(y)) {</span>
                    // treatment of z when not marked
<span class="nc bnc" id="L373" title="All 2 branches missed.">                    if (!mark.get(z).booleanValue()) {</span>
<span class="nc" id="L374">                        mark.put(z, new Boolean(true));</span>
<span class="nc" id="L375">                        this.addEdge(x, z);</span>
<span class="nc" id="L376">                        number++;</span>
<span class="nc" id="L377">                        set.add(z);</span>
                    }
<span class="nc" id="L379">                }</span>
<span class="nc" id="L380">                set.remove(y);</span>
<span class="nc" id="L381">            }</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">            for (Node y : this.getSuccessorNodes(x)) {</span>
<span class="nc" id="L383">                mark.put(y, new Boolean(false));</span>
<span class="nc" id="L384">            }</span>
<span class="nc" id="L385">        }</span>
<span class="nc" id="L386">        return number;</span>
    }

    /* ----------- STATIC GENERATION METHODS ------------- */

    /**
     * Generates the directed asyclic graph (DAG) of divisors for integers
     * included betwwen 2 and the specified value.
     *
     * In this DAG, nodes corresponds to the integers,
     * and there is an edge between two integers if and only if the second one
     * is divisible by the first one.
     *
     * @param   number  the maximal integer
     *
     * @return  the acyclic graph
     */
    public static DAGraph divisors(int number) {
<span class="nc" id="L404">        DAGraph graph = new DAGraph();</span>
        // addition of nodes
<span class="nc bnc" id="L406" title="All 2 branches missed.">        for (int i = 2; i &lt;= number; i++) {</span>
<span class="nc" id="L407">            graph.addNode(new Node(new Integer(i)));</span>
        }
        // addition of edges
<span class="nc bnc" id="L410" title="All 2 branches missed.">        for (Node from : graph.getNodes()) {</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            for (Node to : graph.getNodes()) {</span>
<span class="nc" id="L412">               int v1 = ((Integer) from.getContent()).intValue();</span>
<span class="nc" id="L413">               int v2 = ((Integer) to.getContent()).intValue();</span>
<span class="nc bnc" id="L414" title="All 4 branches missed.">               if (v1 &lt; v2 &amp;&amp; v2 % v1 == 0) {</span>
<span class="nc" id="L415">                   graph.addEdge(from, to);</span>
               }
<span class="nc" id="L417">            }</span>
<span class="nc" id="L418">        }</span>
<span class="nc" id="L419">        return graph;</span>
    }

    /**
     * Generates a random directed and acyclic graph (DAG) of size nodes.
     *
     * @param   size       the number of nodes of the generated graph
     * @param   threshold  the threshold to generate an edge
     *
     * @return  a random acyclic graph
     */
    public static DAGraph random(int size, double threshold) {
<span class="nc" id="L431">        DAGraph graph = new DAGraph();</span>
        // addition of Nodes
<span class="nc bnc" id="L433" title="All 2 branches missed.">        for (int i = 1; i &lt;= size; i++) {</span>
<span class="nc" id="L434">            graph.addNode(new Node(new Integer(i)));</span>
        }
        // addition of edges
<span class="nc bnc" id="L437" title="All 2 branches missed.">        for (Node from : graph.getNodes()) {</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">            for (Node to : graph.getNodes()) {</span>
                // Test to avoid cycles
<span class="nc bnc" id="L440" title="All 2 branches missed.">                if (from.compareTo(to) &gt; 0) {</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">                    if (Math.random() &lt; threshold) {</span>
<span class="nc" id="L442">                        graph.addEdge(from, to);</span>
                    }
                }
<span class="nc" id="L445">            }</span>
<span class="nc" id="L446">        }</span>
<span class="nc" id="L447">        return graph;</span>
    }

    /**
     * Generates a random directed graph of size nodes.
     *
     * @param   size  the number of nodes of the generated graph
     *
     * @return  a random acyclic graph
     */
    public static DAGraph random(int size) {
<span class="nc" id="L458">        return random(size, 0.5);</span>
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312101107</span></div></body></html>